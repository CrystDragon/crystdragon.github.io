<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  

  
  <title>TRA-1 | Lincoln&#39;s SafeHouse</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Tip: 同步 UIView animation 和 CALayer animation  问题来源 解决办法   Receive: Swift Concurrency Algorithm: Substring with Concatenation of All Words  题目 分析 实现 性能分析      TRA 是简化版的 ARTS, 周期是两周一次。其中  T 是 Tip, 总结和归">
<meta property="og:type" content="article">
<meta property="og:title" content="TRA-1">
<meta property="og:url" content="https://crystdragon.github.io/2020/tra-1/">
<meta property="og:site_name" content="Lincoln&#39;s SafeHouse">
<meta property="og:description" content="Tip: 同步 UIView animation 和 CALayer animation  问题来源 解决办法   Receive: Swift Concurrency Algorithm: Substring with Concatenation of All Words  题目 分析 实现 性能分析      TRA 是简化版的 ARTS, 周期是两周一次。其中  T 是 Tip, 总结和归">
<meta property="og:locale">
<meta property="og:image" content="https://crystdragon.github.io/2020/tra-1/leetcode_record.png">
<meta property="article:published_time" content="2020-11-10T04:05:40.000Z">
<meta property="article:modified_time" content="2023-10-24T14:29:11.955Z">
<meta property="article:author" content="Lincoln Wu">
<meta property="article:tag" content="Apple Platforms">
<meta property="article:tag" content="Swift Concurrency">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://crystdragon.github.io/2020/tra-1/leetcode_record.png">
  
    <link rel="alternate" href="/atom.xml" title="Lincoln&#39;s SafeHouse" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.0.0-rc2"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Lincoln&#39;s SafeHouse</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://crystdragon.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-tra-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/tra-1/" class="article-date">
  <time datetime="2020-11-10T04:05:40.000Z" itemprop="datePublished">2020-11-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/tra/">TRA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      TRA-1
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><ul class="markdownIt-TOC">
<li><a href="#tip-%E5%90%8C%E6%AD%A5-uiview-animation-%E5%92%8C-calayer-animation">Tip: 同步 UIView animation 和 CALayer animation</a>
<ul>
<li><a href="#%E9%97%AE%E9%A2%98%E6%9D%A5%E6%BA%90">问题来源</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">解决办法</a></li>
</ul>
</li>
<li><a href="#receive-swift-concurrency">Receive: Swift Concurrency</a></li>
<li><a href="#algorithm-substring-with-concatenation-of-all-words">Algorithm: Substring with Concatenation of All Words</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE">题目</a></li>
<li><a href="#%E5%88%86%E6%9E%90">分析</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0">实现</a></li>
<li><a href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">性能分析</a></li>
</ul>
</li>
</ul>
</p>
<hr />
<p>TRA 是简化版的 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/WMlApIA-v8zpB9l-VlMlyw">ARTS</a>, 周期是两周一次。其中</p>
<ul>
<li>T 是 Tip, 总结和归纳日常中遇到的知识点.</li>
<li>R 是 Receive, 新知识的输入(技术、理财、哲学、文化等)都算在内.</li>
<li>A 是 Algorithm, 算法小练习.</li>
</ul>
<hr />
<span id="more"></span>
<h2 id="tip-同步-uiview-animation-和-calayer-animation"><a class="markdownIt-Anchor" href="#tip-同步-uiview-animation-和-calayer-animation"></a> Tip: 同步 UIView animation 和 CALayer animation</h2>
<h3 id="问题来源"><a class="markdownIt-Anchor" href="#问题来源"></a> 问题来源</h3>
<p>自己在开发一个需求的过程中遇到了这样的问题:</p>
<p>之前有实现好有一个内部通过 <code>CAShaperLayer</code> 绘制 path 的封装好的 <code>UIView</code>. 现在要在这个 view 上实现一个动画效果:  同时动画方式改变这个 view 的 <code>frame</code>/<code>transform</code> 和内部的 path.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyView</span>: <span class="title class_">UIView</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> pathLayer <span class="operator">=</span> <span class="type">CAShapeLayer</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">setPath</span>(<span class="keyword">_</span> <span class="params">path</span>: <span class="type">CGPath</span>?) &#123;</span><br><span class="line">    pathLayer.path <span class="operator">=</span> path</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最开始的尝试方式:</p>
<ul>
<li>针对 view 的 位置动画, 使用 <code>UIView.animate(withDuration:animations:)</code>.</li>
<li>针对 layer 的 path 动画, 手动创建 <code>CABasicAnimation</code>, 并 add 到 layer 上. 之所以用 explicit animation, 是因为:<br />
虽然 <code>CAShaperLayer</code> 的 <code>path</code> 是标记成 animatable 的, 但是和 layer 的其他属性(例如 <code>bounds</code> 等)不同, 直接设置 <code>path</code> 是不会产生 implicit animation 的. <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/quartzcore/cashapelayer/1521904-path">这两点都在文档中有明确标明</a>.</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyView</span>: <span class="title class_">UIView</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> pathLayer <span class="operator">=</span> <span class="type">CAShapeLayer</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">setPath</span>(<span class="keyword">_</span> <span class="params">path</span>: <span class="type">CGPath</span>?) &#123;</span><br><span class="line">    <span class="keyword">let</span> animation <span class="operator">=</span> <span class="type">CABasicAnimation</span>(keyPath: <span class="string">&quot;path&quot;</span>)</span><br><span class="line">    animation.fromValue <span class="operator">=</span> pathLayer.presentationLayer<span class="operator">!</span>.path</span><br><span class="line">    animation.toValue <span class="operator">=</span> path</span><br><span class="line">    animation.duration <span class="operator">=</span> <span class="number">0.2</span></span><br><span class="line">    pathLayer.add(animation, forKey: <span class="string">&quot;animatedPath&quot;</span>)</span><br><span class="line">    pathLayer.path <span class="operator">=</span> path</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/// 动画调用</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">MyView</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">performAnimation</span>() &#123;</span><br><span class="line">    <span class="type">UIView</span>.animate(withDuration: <span class="number">0.2</span>) &#123;</span><br><span class="line">      <span class="keyword">self</span>.frame <span class="operator">=</span> <span class="comment">// new frame</span></span><br><span class="line">      <span class="keyword">self</span>.transform <span class="operator">=</span> <span class="comment">// new transform</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// option 1: setPath 写在 animation block 里</span></span><br><span class="line">      <span class="keyword">self</span>.setPath(<span class="comment">/* new path */</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// option 2: setPath 写在 animation block 外</span></span><br><span class="line">    <span class="keyword">self</span>.setPath(<span class="comment">/* new path */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而仅仅这么做会导致 view 和 layer 的 animation 无法同时作用</p>
<ul>
<li>有时候是出现了启动的时间差</li>
<li>有时候是一个 animation 吃掉了另一个 animation, UI 上出现突变而不是 2 个动画同时进行</li>
</ul>
<h3 id="解决办法"><a class="markdownIt-Anchor" href="#解决办法"></a> 解决办法</h3>
<p>考虑到 <code>UIView.animate()</code> 本质上就是依靠</p>
<ul>
<li><code>UIView</code> 设置自己成为 <code>self.layer</code> 的 <code>delegate</code>, 并且</li>
<li>在 animation block 调用期间, 针对不同的 property 变化通过 <code>CALayerDelegate</code> 中的 <code>action(for:forKey:)</code> 提供 implicit animation</li>
</ul>
<p>来实现的. 而既然 <code>UIView.animate()</code> 可以把一系列 animation 同时启动, 我们只需要也用类似的方式, 在同样的时刻提供 path 动画即可. 而想要参与 layer 的 implicit animation 的自定义过程, 有多种途径, 例如:</p>
<ul>
<li>实现自定义的 layer subclass, 重写 <code>defaultAction(forKey:)</code></li>
<li>给单独的 layer 增加 delegate, 重写 <code>action(for:forKey:)</code></li>
<li>实现自定义的 view subclass, 指定 <code>layerClass</code>, 并重写 <code>action(for:forKey:)</code></li>
</ul>
<p>等. 以下以单独增加 delegate 为例子.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyView</span>: <span class="title class_">UIView</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> pathLayer <span class="operator">=</span> <span class="type">CAShapeLayer</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">CustomLayerDelegate</span>: <span class="title class_">NSObject</span>, <span class="title class_">CALayerDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">action</span>(<span class="params">for</span> <span class="params">layer</span>: <span class="type">CALayer</span>, <span class="params">forKey</span> <span class="params">event</span>: <span class="type">String</span>) -&gt; <span class="type">CAAction</span>? &#123;</span><br><span class="line">      <span class="keyword">guard</span> event <span class="operator">==</span> <span class="string">&quot;path&quot;</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">let</span> animation <span class="operator">=</span> <span class="type">CABasicAnimation</span>(keyPath: event)</span><br><span class="line">      animation.fromValue <span class="operator">=</span> layer.presentationLayer<span class="operator">!</span>.path</span><br><span class="line">      animation.toValue <span class="operator">=</span> path</span><br><span class="line">      animation.duration <span class="operator">=</span> <span class="number">0.2</span></span><br><span class="line">      <span class="keyword">return</span> animation</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> pathLayerDelegate <span class="operator">=</span> <span class="type">CustomLayerDelegate</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(<span class="params">frame</span>: <span class="type">CGRect</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line">    pathLayer.delegate <span class="operator">=</span> pathLayerDelegate</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">setPath</span>(<span class="keyword">_</span> <span class="params">path</span>: <span class="type">CGPath</span>?) &#123;</span><br><span class="line">    pathLayer.path <span class="operator">=</span> path</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 动画调用</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">MyView</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">performAnimation</span>() &#123;</span><br><span class="line">    <span class="type">UIView</span>.animate(withDuration: <span class="number">0.2</span>) &#123;</span><br><span class="line">      <span class="keyword">self</span>.frame <span class="operator">=</span> <span class="comment">// new frame</span></span><br><span class="line">      <span class="keyword">self</span>.transform <span class="operator">=</span> <span class="comment">// new transform</span></span><br><span class="line">      <span class="keyword">self</span>.setPath(<span class="comment">/* new path */</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样每次在 <code>UIView.animate()</code> 的 animation block 中如果更改了 layer 的 <code>path</code>, 就会自动产生一个 implicit animation, 并且能和其他 view animation 并行产生作用.</p>
<h2 id="receive-swift-concurrency"><a class="markdownIt-Anchor" href="#receive-swift-concurrency"></a> Receive: Swift Concurrency</h2>
<p>关于 Swift 中新的并发编程特性的讨论已经在官方 forums <a target="_blank" rel="noopener" href="https://forums.swift.org/t/concurrency-async-await-actors/6516">持续好多年</a>了, 我个人也一直抱有浓厚的兴趣. 上周, Swift core team 终于正式以 <a target="_blank" rel="noopener" href="https://forums.swift.org/t/swift-concurrency-roadmap/41611">1 篇 road map</a> 和 4 篇 proposal 初稿隆重为各位 Swift 爱好者铺展开将会持续未来多个版本的道路. 虽然这些文档仍在积极讨论中, 和终稿相比想必会有很大的不同, 但我坚信, 相关的思想和观念将是一名优秀 Swifter 以后绕不开的宝库.</p>
<p>对于 iOS 开发者而言, 异步编程是再熟悉不过了, 平时日常开发中即使不涉及到多线程通信的问题, 也至少懂得&quot;繁琐操作不应该 block 主线程&quot;的道理. 而这次 Swift team 带来的 proposal 不但能免去我们开发者平时遇到的一些烦恼, 也能在更高的 level 上系统化地解决并发编程中的一些基本问题.</p>
<p>这里无法详述所有细节, 仅将相关 proposal 的主旨摘录于下:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/DougGregor/swift-evolution/blob/async-await/proposals/nnnn-async-await.md">Async/await</a> 为语言引入了一种新的 function: async function (包括 method).
<ul>
<li>Async function 与普通 function 是两个世界, 无法互相调用, 只能在各自的 context 中调用.
<ul>
<li>声明方式 <code>func asyncFunction(_ input: Int) async -&gt; Int</code> .</li>
<li>调用方式 <code>let result = await asyncFunction(10)</code>.</li>
</ul>
</li>
<li>Async function 调用后, 只能异步地返回.
<ul>
<li>从语法角度, 可以认为 async function 是带 callback block 的普通 function 的语法糖.</li>
<li>从语义角度, async 是协程 (coroutine) 的应用: 在 async context 下每次 await, 都产生了断点, 当前协程中断, 直到被调用的 async function 异步完成时, 才会把返回值提供给 caller, caller 协程接着上次断点继续执行.</li>
</ul>
</li>
<li>Async function 可以极大简化普通 function 中因为大量使用 callback block 造成的书写问题, 例如:
<ul>
<li>回调地狱——深层的 callback 嵌套.</li>
<li>数据流容易丢失——使用 callback 时编译器无法保证, 被调方法能一致地返回.</li>
<li>try catch 机制无法用于 callback 方法.</li>
</ul>
</li>
</ul>
</li>
<li>Async/await 只是引入了最基本的异步语法, 但日常应用需要有更高级的抽象. <a target="_blank" rel="noopener" href="https://github.com/DougGregor/swift-evolution/blob/structured-concurrency/proposals/nnnn-structured-concurrency.md">Structured concurrency</a> 在语言层面增加了许多机制.
<ul>
<li>虽然 async function 异步执行, 但和普通 function 一样, 在执行过程中, 它与它内部所有 await 的操作也形成自然的树状&quot;父子&quot;结构, 系统可以保证所有子任务不会无故超越父任务的生命期.
<ul>
<li>支持协作式的 cancellation: 任何子任务被 cancel, 父任务会同步自动进入 cancel 状态, 其他执行中的子任务也可以主动获取到 cancel 信息.</li>
<li>在一个任务中需要多个子任务并发处理的情况下:
<ul>
<li>可以通过 <code>async let</code> binding 可以并发执行多个 async function, 并在同一的地方 await 多个任务的完成.</li>
<li>也可以通过 <code>Task.Nursery</code> 动态方式开始和结束任意数量的子任务.</li>
</ul>
</li>
</ul>
</li>
<li>在每一个 async function,中 都可以通过系统提供的 <code>Task</code> 类型, 实现许多并发机制.
<ul>
<li>如上所说, <code>Task.Nursery</code> 可以动态并行开启子任务.</li>
<li>使用 <code>Task.isCancelled()</code> 等方法, 得知当前 task 是否被标记 cancelled.</li>
<li>使用 <code>Task.withDeadline()</code> 和 <code>Task.currentDeadline().remaining</code> 可以开启有时限的任务和检测时限是否已达.</li>
</ul>
</li>
<li><code>Task</code> 还可以联系 async 和 non-async 世界:
<ul>
<li><code>Task.runDetached()</code> 允许我们从普通的非 async 代码进入一个 async context, 从而可以调用 async function.</li>
<li><code>Task.withUnsafeContinuation()</code> 允许从一个 async context 中临时转移到 non-async context, 执行我们的基于普通 callback block 的代码, 并等待回调.</li>
</ul>
</li>
</ul>
</li>
<li>上面 2 个 protocol 解决了并发编程中的一些效率问题, 而 <a target="_blank" rel="noopener" href="https://github.com/DougGregor/swift-evolution/blob/actors/proposals/nnnn-actors.md">Actors</a> 可以帮忙解决更困难和危险的问题——如何保证并发下的运行安全. 例如 data race, deadlock.
<ul>
<li>引入了一种新的 type 类别: <code>actor class</code>.
<ul>
<li>每一个 actor class 的实例对象, 背后都有一个 “queue” , 语言制定了一些列规则来保证所有该对象的方法默认都只能在该 queue 上执行, 并且当前 actor 的 value semantics 成员都不会被其他 actor 不安全地访问. 从而部分解决了 data race 问题.
<ul>
<li>要访问的是 stored property 时, 只有当编译器能确保以下条件时,  才允许访问: 或者能保证该 property 是 immutable, 或者能保证访问只发生在 <code>self</code> 上.</li>
<li>要访问的是 non-async 方法时, 只允许在该 method 在 <code>self</code> 上调用, 不允许在别的对象上调用.</li>
<li>要访问的是 async 方法时, 没有限制. 而由于调用者只能异步等待返回, 因此解决了死锁问题.</li>
<li>当然针对不同情况, proposal 也提供了一些手段让开发者帮编译器作强制指定.</li>
</ul>
</li>
<li>对于全局方法, 虽然不在 actor class 内, 但可以给其标记属于某个 global actor, 所有的访问都等价于在这个 actor singleton 上执行.</li>
</ul>
</li>
<li>官方 forums 的 proposal 只针对 value semantics 的类型提供了检查, 而对其他类型的支持将会在以后加入. 这等于在以后版本加强了语言限制, 会导致现在 valid 的 code 以后某个版本不 valid.
<ul>
<li>社区中针对这一问题, 许多大佬 (比如 Christ Lattner, Dave Abrahams) 提出了另一种策略: <a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1OMHZKWq2dego5mXQtWt1fm-yMca2qeOdCl8YlBG1uwg">Protocol-based Actor Isolation</a>.</li>
<li>这个 proposal 里建议一开始就限制允许在不同 actor 接口间传递的数据的类型, 并允许标准库和开发者有办法让自己的类型满足要求.</li>
</ul>
</li>
</ul>
</li>
<li>最后, Swift 当前的首要用户必然是 ObjC 开发者, 而为 Swift 特性和 ObjC 交互也始终是首要任务之一. 因此将 async/await 甚至 actor 和 ObjC 打通也必然极有意义. <a target="_blank" rel="noopener" href="https://github.com/DougGregor/swift-evolution/blob/concurrency-objc/proposals/NNNN-concurrency-objc.md">Concurrency Interoperability with Objective-C</a> 就给这一块补上了许多支持.
<ul>
<li>ObjC 中编写的基于 callback block 的方法, 在 bridge 到 Swift 时, 除了原有的 API, 符合条件时还会额外生成一个 async API.</li>
<li>Swift 中编写的 async API, 用 <code>@objc</code> 暴露给 ObjC 时, 会自动转换成 callback block 形式.</li>
<li>Swift 中编写的 actor class, 其 <code>@objc</code> 方法暴露给 ObjC 调用时, 会自动执行在对应 actor 的 “queue” 上.</li>
</ul>
</li>
</ul>
<h2 id="algorithm-substring-with-concatenation-of-all-words"><a class="markdownIt-Anchor" href="#algorithm-substring-with-concatenation-of-all-words"></a> Algorithm: Substring with Concatenation of All Words</h2>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<p>来自 <a target="_blank" rel="noopener" href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/">leetcode</a>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</span><br><span class="line"> </span><br><span class="line">输入：</span><br><span class="line">  s = &quot;barfoothefoobarman&quot;,</span><br><span class="line">  words = [&quot;foo&quot;,&quot;bar&quot;]</span><br><span class="line">输出：[0,9]</span><br><span class="line">解释：</span><br><span class="line">从索引 0 和 9 开始的子串分别是 &quot;barfoo&quot; 和 &quot;foobar&quot; 。</span><br><span class="line">输出的顺序不重要, [9,0] 也是有效答案。</span><br></pre></td></tr></table></figure>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>假设待匹配的每个 word 的宽度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>.<br />
第一印象使用滑动窗口. 我们只检查字符串在滑动窗口中的部分, 是否是输入 words 的一个连接. 因为 words 都是等宽度的, 所以如果滑动窗口内的部分确实是连接, 那么按 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 为宽度进行划分后形成的 substring 集合, 必然等价于输入的 words 集合. 使用滑动窗口, 我们就可以一个字符一个字符地考察, 每增加一个字符, 可能产生新的 match.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// [  ] 对应 word 的宽度</span><br><span class="line"></span><br><span class="line">              |-新探测的字符</span><br><span class="line">              v</span><br><span class="line"> xxxxx.....xxxAxxx...</span><br><span class="line">  [  ][  ][  ] </span><br><span class="line">  ^          ^</span><br><span class="line">  |--window--| </span><br></pre></td></tr></table></figure>
<p>然而, 每次新增字符要检查滑动窗口部分是否 match 了所有的 word 是无需从窗口头部开始重新检查, 有很多数据是可以复用的. 只是这个复用并不是紧邻的, 也就是考察上一个字符时和和考察接下来的字符时, 并不能共享信息. 而是当前的滑动窗口状态和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 个字符前的状态有很大的相似性.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// [  ] 对应 word 的宽度</span><br><span class="line"></span><br><span class="line">  |--old window--|</span><br><span class="line">  [  ][  ][  ][  ]        &lt;- 之前可能的匹配</span><br><span class="line">  xxxxxxxxxxxxxxxxxxxx</span><br><span class="line">      [  ][  ][  ][  ]    &lt;- 移动 w 个字符后的匹配</span><br><span class="line">      |--new window--|</span><br></pre></td></tr></table></figure>
<p>因此, 可以拆分出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 个不同的 “赛道”, 不同的赛道之间 offset 为 1, 每个赛道仅在新增 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 个字符后才考察状态变化: 是否产生了新的匹配.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// [  ] 对应 word 的宽度</span><br><span class="line"></span><br><span class="line">   xxxxxxxxxxxxxxxxxxxx</span><br><span class="line">   [  ][  ][  ][  ]       &lt;- 赛道 0</span><br><span class="line">    [  ][  ][  ][  ]      &lt;- 赛道 1</span><br><span class="line">     [  ][  ][  ][  ]     &lt;- 赛道 2</span><br><span class="line">      [  ][  ][  ][  ]    &lt;- 赛道 3</span><br><span class="line">       [  ][  ][  ][  ]   &lt;- 赛道 0 (新增 w 字符后)</span><br></pre></td></tr></table></figure>
<p>如前所述, 每个赛道中上一次匹配的状态和下一次匹配的状态有很大的可复用性. 理论上, 只需要记录这个赛道中所有 substring 出现的次数, 每次新增/删除 substring 后, 检查各个 substring 的 count 是否和目标一致即可. 然而在具体的实现时, code 层面有办法做很大的优化, 避免真的遍历所有的 substring 的 count.</p>
<h3 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h3>
<p>首先实现一个 word 匹配器, 该匹配器做了优化, 使得检查输入的 words 是否正好和目标匹配, 能在短时间内完成. 为此, 在每次新增/删除 word 时, 多做了一些状态维护.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 存储待匹配的 word 及每个 word 目前的匹配情况</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleMultiSet</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// word: count</span></span><br><span class="line">  <span class="comment">/// &lt; 0 的 count 表示仍需一定数量的匹配</span></span><br><span class="line">  <span class="comment">/// &gt; 0 的 count 表示超出了匹配</span></span><br><span class="line">  <span class="comment">/// 不存在的 word 表示正好匹配</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> dict: [<span class="type">Substring</span>: <span class="type">Int</span>] <span class="operator">=</span> [:]</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 用待匹配的 words 初始化</span></span><br><span class="line">  <span class="keyword">init</span>(<span class="params">words</span>: [<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words &#123;</span><br><span class="line">      dict[word[<span class="operator">...</span>], <span class="keyword">default</span>: <span class="number">0</span>] <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 新增加一个 candidate</span></span><br><span class="line">  <span class="comment">/// 理论上, 对应 word 的 count + 1</span></span><br><span class="line">  <span class="comment">/// 但当调整会导致 count == 0 时, 同时将 word 从 dict 里移除</span></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">push</span>(<span class="keyword">_</span> <span class="params">word</span>: <span class="type">Substring</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> count <span class="operator">=</span> dict[word] &#123;</span><br><span class="line">      <span class="keyword">if</span> count <span class="operator">==</span> <span class="operator">-</span><span class="number">1</span> &#123;</span><br><span class="line">        dict[word] <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dict[word] <span class="operator">=</span> count <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dict[word] <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 去掉一个 candidate</span></span><br><span class="line">  <span class="comment">/// 理论上, 对应 word 的 count - 1</span></span><br><span class="line">  <span class="comment">/// 但当调整会导致 count == 0 时, 同时将 word 从 dict 里移除</span></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">remove</span>(<span class="keyword">_</span> <span class="params">word</span>: <span class="type">Substring</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> count <span class="operator">=</span> dict[word] &#123;</span><br><span class="line">      <span class="keyword">if</span> count <span class="operator">==</span> <span class="number">1</span> &#123;</span><br><span class="line">        dict[word] <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dict[word] <span class="operator">=</span> count <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dict[word] <span class="operator">=</span> <span class="operator">-</span><span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 检查是否所有初始的 word 都正好匹配完</span></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">verify</span>() -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dict.isEmpty</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此基础上根据上面的多赛道滑动窗口分析, 实现主算法.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Main entry point</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">findSubstring</span>(<span class="keyword">_</span> <span class="params">s</span>: <span class="type">String</span>, <span class="keyword">_</span> <span class="params">words</span>: [<span class="type">String</span>]) -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="comment">/// early exit</span></span><br><span class="line">  <span class="keyword">if</span> words.isEmpty <span class="operator">||</span> words[<span class="number">0</span>].isEmpty &#123;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> wordSize <span class="operator">=</span> words[<span class="number">0</span>].count</span><br><span class="line">  <span class="keyword">let</span> count <span class="operator">=</span> words.count <span class="operator">*</span> wordSize</span><br><span class="line">  <span class="keyword">if</span> s.count <span class="operator">&lt;</span> count &#123;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 根据 word 宽度决定当前的赛道个数</span></span><br><span class="line">  <span class="keyword">let</span> sets <span class="operator">=</span> (<span class="number">0</span><span class="operator">..&lt;</span>wordSize).map &#123; <span class="keyword">_</span> <span class="keyword">in</span> <span class="type">SimpleMultiSet</span>(words: words) &#125;</span><br><span class="line">  <span class="comment">/// 当前赛道</span></span><br><span class="line">  <span class="keyword">var</span> setIndex <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 各个字符的 index</span></span><br><span class="line">  <span class="comment">// 当前 word start</span></span><br><span class="line">  <span class="keyword">var</span> i <span class="operator">=</span> s.startIndex</span><br><span class="line">  <span class="comment">// 当前 word end</span></span><br><span class="line">  <span class="keyword">var</span> j <span class="operator">=</span> s.index(i, offsetBy: wordSize)</span><br><span class="line">  <span class="comment">// 最旧的 word start</span></span><br><span class="line">  <span class="keyword">var</span> k <span class="operator">=</span> i</span><br><span class="line">  <span class="comment">// 最旧的 word end</span></span><br><span class="line">  <span class="keyword">var</span> l <span class="operator">=</span> j</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> stepper <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> setLoopCount <span class="operator">=</span> wordSize</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> results: [<span class="type">Int</span>] <span class="operator">=</span> []</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 增加初始的 word</span></span><br><span class="line">  sets[setIndex].push(s[i<span class="operator">..&lt;</span>j])</span><br><span class="line">  <span class="keyword">if</span> sets[setIndex].verify() &#123;</span><br><span class="line">    results.append(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> j <span class="operator">!=</span> s.endIndex &#123;</span><br><span class="line">    <span class="comment">/// 每新增一个字符, 决定当前赛道</span></span><br><span class="line">    stepper <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    setIndex <span class="operator">=</span> (setIndex <span class="operator">+</span> <span class="number">1</span>) <span class="operator">%</span> setLoopCount</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 去掉超出窗口的 word</span></span><br><span class="line">    <span class="keyword">if</span> stepper <span class="operator">&gt;=</span> count &#123;</span><br><span class="line">      sets[setIndex].remove(s[k<span class="operator">..&lt;</span>l])</span><br><span class="line">      s.formIndex(after: <span class="operator">&amp;</span>k)</span><br><span class="line">      s.formIndex(after: <span class="operator">&amp;</span>l)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/// 增加新的 word</span></span><br><span class="line">    s.formIndex(after: <span class="operator">&amp;</span>i)</span><br><span class="line">    s.formIndex(after: <span class="operator">&amp;</span>j)</span><br><span class="line">    sets[setIndex].push(s[i<span class="operator">..&lt;</span>j])</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 检查当前赛道是否正好匹配</span></span><br><span class="line">    <span class="keyword">if</span> sets[setIndex].verify() &#123;</span><br><span class="line">      results.append(stepper <span class="operator">-</span> count <span class="operator">+</span> wordSize)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体上使用了 Swift <code>String</code> 的 index 和 <code>Substring</code> 操作避免产生不需要的 copy.</p>
<h3 id="性能分析"><a class="markdownIt-Anchor" href="#性能分析"></a> 性能分析</h3>
<p>假设有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个 word 待匹配, 每个 word 宽度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>, 输入字符串的长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>.</p>
<ul>
<li>时间上
<ul>
<li>初始化阶段: 对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 个赛道每个都创建 <code>SimpleMultiSet</code>. 每次创建时 <code>SimpleMultiSet</code> 需要将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个 word 加入 dict, 考虑到 word 加入 dict 时的 hash 操作, 理论上会遍历 word 中的每个字符, 因此每次初始化耗时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>⋅</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k \cdot w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>. 因此初始化阶段总耗时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>⋅</mo><msup><mi>w</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k \cdot w^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</li>
<li>运行阶段: 是一个 main loop, 针对输入字符串中的字符循环 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>−</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">l - w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 次. 每次循环引入一个新的字符, 最多只需要从对应赛道的 <code>SimpleMultiSet</code> 中增加一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 长度的 substring, 并去掉一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 长度的 substring. 考虑到 word 加入和离开 dict 时的 hash 操作, 最多只需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>. 其他操作都可以在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 内完成, 所以总耗时为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>w</mi><mo>⋅</mo><mo stretchy="false">(</mo><mi>l</mi><mo>−</mo><mi>w</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(w \cdot (l - w))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>. 一般而言 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>≪</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">w \ll l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≪</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>, 因此可近似为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>w</mi><mo>⋅</mo><mi>l</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(w \cdot l)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span>.</li>
<li>总耗时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mo>⋅</mo><mi>w</mi><mo>+</mo><mi>k</mi><mo>⋅</mo><msup><mi>w</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(l \cdot w + k \cdot w^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>. 一般情况下, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≪</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">k \ll l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≪</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>, 或可把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 视为常数, 此时总耗时为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mo>⋅</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(l \cdot w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>. 如果进一步把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 也视为常数, 则最终时间复杂度仅为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(l)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span>.</li>
</ul>
</li>
<li>空间上
<ul>
<li>主要存储消耗为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 个赛道对应的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 个 <code>SimpleMultiSet</code> .</li>
<li>每个 <code>SimpleMultiSet</code> 最多时需要存储 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个宽度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 的substring. 简化来看, 如果把存储 substring 用的 dict 的装载因子视为常数, 则单个 dict 占用空间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>w</mi><mo>⋅</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(w \cdot k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>.</li>
<li>总占用空间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>⋅</mo><msup><mi>w</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k \cdot w^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, 如果把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 均视为常数, 那么整体空间复杂度仅为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>.</li>
</ul>
</li>
</ul>
<p><img src="leetcode_record.png" alt="leetcode record" /><br />
(leetcode 上的耗时分析和 server 上的 Swift 版本有很大关系, 实际参考价值有限)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://crystdragon.github.io/2020/tra-1/" data-id="clo5yfg70000i1e3naouk57qa" class="article-share-link">Share</a>
      
        <a href="https://crystdragon.github.io/2020/tra-1/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/apple-platforms/" rel="tag">Apple Platforms</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/swift-concurrency/" rel="tag">Swift Concurrency</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/tra-2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          TRA-2
        
      </div>
    </a>
  
  
    <a href="/2020/swiftui-notes/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">SwiftUI Notes</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/apple-platforms/">Apple Platforms</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/architecture/">Architecture</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/computer-systems/">Computer Systems</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/diary/">Diary</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/notes/">Notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/swift/">Swift</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tra/">TRA</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/arc/" rel="tag">ARC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/avfoundation/" rel="tag">AVFoundation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apple-platforms/" rel="tag">Apple Platforms</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cow/" rel="tag">COW</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cryptography/" rel="tag">Cryptography</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/functional-programming/" rel="tag">Functional Programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/image/" rel="tag">Image</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/notificationcenter/" rel="tag">NotificationCenter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swift-concurrency/" rel="tag">Swift Concurrency</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swiftui/" rel="tag">SwiftUI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/testing/" rel="tag">Testing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thread-safety/" rel="tag">Thread Safety</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uikit/" rel="tag">UIKit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xcode/" rel="tag">Xcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pointfree-co/" rel="tag">pointfree.co</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/arc/" style="font-size: 10px;">ARC</a> <a href="/tags/avfoundation/" style="font-size: 10px;">AVFoundation</a> <a href="/tags/apple-platforms/" style="font-size: 20px;">Apple Platforms</a> <a href="/tags/cow/" style="font-size: 10px;">COW</a> <a href="/tags/cryptography/" style="font-size: 10px;">Cryptography</a> <a href="/tags/functional-programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/image/" style="font-size: 10px;">Image</a> <a href="/tags/notificationcenter/" style="font-size: 10px;">NotificationCenter</a> <a href="/tags/swift-concurrency/" style="font-size: 10px;">Swift Concurrency</a> <a href="/tags/swiftui/" style="font-size: 10px;">SwiftUI</a> <a href="/tags/testing/" style="font-size: 10px;">Testing</a> <a href="/tags/thread-safety/" style="font-size: 10px;">Thread Safety</a> <a href="/tags/uikit/" style="font-size: 10px;">UIKit</a> <a href="/tags/xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/pointfree-co/" style="font-size: 10px;">pointfree.co</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/swift-cow-correctness/">讨论编写 Copy-on-Write 的正确姿势</a>
          </li>
        
          <li>
            <a href="/2021/tra-4/">TRA-4</a>
          </li>
        
          <li>
            <a href="/2020/tra-3/">TRA-3</a>
          </li>
        
          <li>
            <a href="/2020/tra-2/">TRA-2</a>
          </li>
        
          <li>
            <a href="/2020/tra-1/">TRA-1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Lincoln Wu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'crystdragon';
  
  var disqus_url = 'https://crystdragon.github.io/2020/tra-1/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<!--for katex to work-->
<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<!--for highlight to work-->
<!-- <link rel="stylesheet"
      href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.2/build/styles/tomorrow-night-eighties.min.css">
<script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.2/build/highlight.min.js">
</script>
<script>
    hljs.initHighlightingOnLoad();
</script> -->



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>