<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lincoln&#39;s SafeHouse</title>
  
  <subtitle>Home of a Swifter on Apple platforms</subtitle>
  <link href="https://crystdragon.github.io/atom.xml" rel="self"/>
  
  <link href="https://crystdragon.github.io/"/>
  <updated>2020-11-29T14:24:26.127Z</updated>
  <id>https://crystdragon.github.io/</id>
  
  <author>
    <name>Lincoln Wu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TRA-2</title>
    <link href="https://crystdragon.github.io/2020/tra-2/"/>
    <id>https://crystdragon.github.io/2020/tra-2/</id>
    <published>2020-11-29T12:57:49.000Z</published>
    <updated>2020-11-29T14:24:26.127Z</updated>
    
    <content type="html"><![CDATA[<p><ul class="markdownIt-TOC"><li><a href="#tip-%E7%BB%9F%E4%B8%80%E9%9A%90%E8%97%8F-type-%E7%9A%84-property-setter">Tip: 统一隐藏 Type 的 property setter</a></li><li><a href="#receive-%E5%9C%A8-app-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%94%B6%E9%9B%86-code-coverage-%E4%BF%A1%E6%81%AF">Receive: 在 App 运行时收集 code coverage 信息</a></li><li><a href="#algorithm-divide-two-integers">Algorithm: Divide Two Integers</a><ul><li><a href="#%E9%A2%98%E7%9B%AE">题目</a></li><li><a href="#%E5%AE%9E%E7%8E%B0">实现</a></li></ul></li></ul></p><hr><a id="more"></a><h2 id="tip-统一隐藏-type-的-property-setter"><a class="markdownIt-Anchor" href="#tip-统一隐藏-type-的-property-setter"></a> Tip: 统一隐藏 Type 的 property setter</h2><p>在编写程序时, 经常需要仔细设计一个 model 的各个 property 的读写性质. 通常, 为了方便, 我们会把 model 的所有 property 设为 var, 来允许我们的一部分代码对 property 进行延迟赋值或者其他修改.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// implementation</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getModel</span><span class="params">()</span></span> -&gt; <span class="type">Model</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">Model</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// client</span></span><br><span class="line"><span class="keyword">var</span> model = getModel()</span><br><span class="line"><span class="built_in">print</span>(model.value)</span><br><span class="line"><span class="built_in">print</span>(model.name)</span><br><span class="line">model.value = <span class="number">3</span></span><br><span class="line">model.name = <span class="string">"default"</span></span><br></pre></td></tr></table></figure><p>然而, 在大型程序中, 我们并不希望所有该 model 的访问者都可以随意修改 property, 它们只需要使用 getter, 而不应该调用 setter. 于是, 有些情况下会选择给使用者提供另一个只读的 model.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ClientModel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span>(<span class="number">_</span> model: <span class="type">Model</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.value = model.value</span><br><span class="line">    <span class="keyword">self</span>.name = model.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// implementation</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getModel2</span><span class="params">()</span></span> -&gt; <span class="type">ClientModel</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">ClientModel</span>(<span class="type">Model</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// client</span></span><br><span class="line"><span class="keyword">var</span> model2 = getModel2()</span><br><span class="line"><span class="built_in">print</span>(model2.value)</span><br><span class="line"><span class="built_in">print</span>(model2.name)</span><br><span class="line">model2.value = <span class="number">3</span>        <span class="comment">// compiler error</span></span><br><span class="line">model2.name = <span class="string">"default"</span> <span class="comment">// compiler error</span></span><br></pre></td></tr></table></figure><p>然而, 如果很多 model 都有这个需求, 将会导致 code 中出现很多重复的实现代码.</p><p>使用 Swift 中的 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0252-keypath-dynamic-member-lookup.md" target="_blank" rel="noopener">dynamicMenmberLookup 的 keyPath 静态版本</a>, 可以大量简化这一工作: 我们只需要定义一个 generic 的 readonly wrapper, 就可以套用到任意的 model 类型上.<br>这里使用的 Swift 特性 dynamicMenmberLookup 可以起到类似 c++ 中重载 “.” 和 “-&gt;” 运算符的效果, 将对某个对象的 property access 转发到另一个内部对象上.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dynamicMemberLookup</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ReadOnly</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> _base: <span class="type">T</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(<span class="number">_</span> base: <span class="type">T</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>._base = base</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">subscript</span>&lt;<span class="type">Value</span>&gt;(dynamicMember keyPath: <span class="type">KeyPath</span>&lt;<span class="type">T</span>, <span class="type">Value</span>&gt;) -&gt; <span class="type">Value</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _base[keyPath: keyPath]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// implementation</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getModel3</span><span class="params">()</span></span> -&gt; <span class="type">ReadOnly</span>&lt;<span class="type">Model</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">ReadOnly</span>(<span class="type">Model</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// client</span></span><br><span class="line"><span class="keyword">var</span> model3 = getModel3()</span><br><span class="line"><span class="built_in">print</span>(model3.value)</span><br><span class="line"><span class="built_in">print</span>(model3.name)</span><br><span class="line">model3.value = <span class="number">3</span>        <span class="comment">// compiler error</span></span><br><span class="line">model3.name = <span class="string">"default"</span> <span class="comment">// compiler error</span></span><br></pre></td></tr></table></figure><p>在上面的实现中, 我们只提供了接受 <code>KeyPath</code> 参数的 subscript, 而没有提供 <code>WritableKeyPath</code> 参数的版本, 从而在接口上消除了所有 property setter.</p><h2 id="receive-在-app-运行时收集-code-coverage-信息"><a class="markdownIt-Anchor" href="#receive-在-app-运行时收集-code-coverage-信息"></a> Receive: 在 App 运行时收集 code coverage 信息</h2><p>最近参加公司内部的一次技术分享, 该分享介绍了一个工具, 可以在 App 测试过程中收集开发编写的代码的运行情况, 做到动态 code coverage 收集.</p><p>之前我只了解, 使用 Xcode 跑 Unit Test 时, Apple 会插入一些新的编译/链接选项, 给运行的 code 进行插桩, 并在 code 运行完后根据运行时的记录信息生成报告; 但是我并不知道运行中的 App 本身是否能获取到自身运行的情况. 经过一些 searching, 原来 LLVM 是支持这一操作的, 也有官方文档详细描述了使用姿势. 核心要点摘录如下:</p><ul><li><a href="https://clang.llvm.org/docs/SourceBasedCodeCoverage.html" target="_blank" rel="noopener">Source-based Code Coverage</a> 描述了主要的 code coverage 流程<ul><li><a href="https://clang.llvm.org/docs/SourceBasedCodeCoverage.html#using-the-profiling-runtime-without-static-initializers" target="_blank" rel="noopener">Using the profiling runtime without static initializers</a>这一节主要描述了如何在运行时获取到 profile 信息<ul><li><code>__llvm_profile_set_filename</code> 可以设置 profile file 的路径</li><li><code>__llvm_profile_write_file</code> 调用一次可以把当前的 profile 写到指定的路径</li></ul></li><li>llvm 提供了 llvm-profdata 和 llvm-cov 等工具来处理生成的 profile 文件, 并解析成可读的 JSON 格式</li></ul></li><li><a href="https://clang.llvm.org/docs/UsersManual.html#profiling-with-instrumentation" target="_blank" rel="noopener">Clang 文档</a>也有关于 profile 的一些例子, 并且详细阐述了一些 compiler flag 的用法.</li></ul><h2 id="algorithm-divide-two-integers"><a class="markdownIt-Anchor" href="#algorithm-divide-two-integers"></a> Algorithm: Divide Two Integers</h2><h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3><p>来自 <a href="https://leetcode.com/problems/divide-two-integers/submissions/" target="_blank" rel="noopener">leetcode</a>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Given two integers dividend and divisor, </span><br><span class="line">divide two integers without using multiplication, </span><br><span class="line">division, and mod operator.</span><br><span class="line"></span><br><span class="line">Return the quotient after dividing dividend by divisor.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">Input: dividend = 10, divisor = 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 10/3 = truncate(3.33333..) = 3.</span><br></pre></td></tr></table></figure><h3 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h3><p>禁止乘法和除法的情况下, 理论上计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">a / b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">b</span></span></span></span> 只需要在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 上不断减去 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>, 直到无数可减. 但这样性能不高, 实际上随着商的位数增加, 每次可以减的可以比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 更多. 如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>b</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a / b = c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>, 把 c 按二进制方式写成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>k</mi></msub><msub><mi>c</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">c_k c_{k-1} ... c_1 c_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 每一位的贡献是后一项的两倍.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(<span class="number">_</span> dividend: Int, <span class="number">_</span> divisor: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> dividend &lt;= <span class="type">Int32</span>.<span class="built_in">min</span> &amp;&amp; divisor == -<span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Int</span>(<span class="type">Int32</span>.<span class="built_in">max</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> isPositive = (dividend &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>) == <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> dividend = dividend &gt; <span class="number">0</span> ? dividend : -dividend</span><br><span class="line">  <span class="keyword">let</span> divisor = divisor &gt; <span class="number">0</span> ? divisor : -divisor</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> divisor &gt; dividend &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 构造余数各位的贡献, 对应余数每一位乘以除数后的值</span></span><br><span class="line">  <span class="keyword">var</span> factors: [(<span class="type">Int</span>, <span class="type">Int</span>)] = []</span><br><span class="line">  <span class="keyword">var</span> factor = divisor</span><br><span class="line">  <span class="keyword">var</span> scale = <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">repeat</span> &#123;</span><br><span class="line">    factors.append((factor, scale))</span><br><span class="line">    factor *= <span class="number">2</span></span><br><span class="line">    scale *= <span class="number">2</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (factor &lt;= dividend)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> remaining = dividend</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 从贡献高的位开始不断尝试, 够减就表示该位为 1</span></span><br><span class="line">  <span class="keyword">for</span> (factor, scale) <span class="keyword">in</span> factors.reversed() &#123;</span><br><span class="line">    <span class="keyword">if</span> remaining &gt;= factor &#123;</span><br><span class="line">      result += scale</span><br><span class="line">      remaining -= factor</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isPositive ? result : -result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;ul class=&quot;markdownIt-TOC&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#tip-%E7%BB%9F%E4%B8%80%E9%9A%90%E8%97%8F-type-%E7%9A%84-property-setter&quot;&gt;Tip: 统一隐藏 Type 的 property setter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#receive-%E5%9C%A8-app-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%94%B6%E9%9B%86-code-coverage-%E4%BF%A1%E6%81%AF&quot;&gt;Receive: 在 App 运行时收集 code coverage 信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#algorithm-divide-two-integers&quot;&gt;Algorithm: Divide Two Integers&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%A2%98%E7%9B%AE&quot;&gt;题目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%9E%E7%8E%B0&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="TRA" scheme="https://crystdragon.github.io/categories/tra/"/>
    
    
  </entry>
  
  <entry>
    <title>TRA-1</title>
    <link href="https://crystdragon.github.io/2020/tra-1/"/>
    <id>https://crystdragon.github.io/2020/tra-1/</id>
    <published>2020-11-10T04:05:40.000Z</published>
    <updated>2020-11-11T11:47:12.564Z</updated>
    
    <content type="html"><![CDATA[<p><ul class="markdownIt-TOC"><li><a href="#tip-%E5%90%8C%E6%AD%A5-uiview-animation-%E5%92%8C-calayer-animation">Tip: 同步 UIView animation 和 CALayer animation</a><ul><li><a href="#%E9%97%AE%E9%A2%98%E6%9D%A5%E6%BA%90">问题来源</a></li><li><a href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">解决办法</a></li></ul></li><li><a href="#receive-swift-concurrency">Receive: Swift Concurrency</a></li><li><a href="#algorithm-substring-with-concatenation-of-all-words">Algorithm: Substring with Concatenation of All Words</a><ul><li><a href="#%E9%A2%98%E7%9B%AE">题目</a></li><li><a href="#%E5%88%86%E6%9E%90">分析</a></li><li><a href="#%E5%AE%9E%E7%8E%B0">实现</a></li><li><a href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">性能分析</a></li></ul></li></ul></p><hr><p>TRA 是简化版的 <a href="https://mp.weixin.qq.com/s/WMlApIA-v8zpB9l-VlMlyw" target="_blank" rel="noopener">ARTS</a>, 周期是两周一次。其中</p><ul><li>T 是 Tip, 总结和归纳日常中遇到的知识点.</li><li>R 是 Receive, 新知识的输入(技术、理财、哲学、文化等)都算在内.</li><li>A 是 Algorithm, 算法小练习.</li></ul><hr><a id="more"></a><h2 id="tip-同步-uiview-animation-和-calayer-animation"><a class="markdownIt-Anchor" href="#tip-同步-uiview-animation-和-calayer-animation"></a> Tip: 同步 UIView animation 和 CALayer animation</h2><h3 id="问题来源"><a class="markdownIt-Anchor" href="#问题来源"></a> 问题来源</h3><p>自己在开发一个需求的过程中遇到了这样的问题:</p><p>之前有实现好有一个内部通过 <code>CAShaperLayer</code> 绘制 path 的封装好的 <code>UIView</code>. 现在要在这个 view 上实现一个动画效果:  同时动画方式改变这个 view 的 <code>frame</code>/<code>transform</code> 和内部的 path.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> pathLayer = <span class="type">CAShapeLayer</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">setPath</span><span class="params">(<span class="number">_</span> path: CGPath?)</span></span> &#123;</span><br><span class="line">    pathLayer.path = path</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最开始的尝试方式:</p><ul><li>针对 view 的 位置动画, 使用 <code>UIView.animate(withDuration:animations:)</code>.</li><li>针对 layer 的 path 动画, 手动创建 <code>CABasicAnimation</code>, 并 add 到 layer 上. 之所以用 explicit animation, 是因为:<br>虽然 <code>CAShaperLayer</code> 的 <code>path</code> 是标记成 animatable 的, 但是和 layer 的其他属性(例如 <code>bounds</code> 等)不同, 直接设置 <code>path</code> 是不会产生 implicit animation 的. <a href="https://developer.apple.com/documentation/quartzcore/cashapelayer/1521904-path" target="_blank" rel="noopener">这两点都在文档中有明确标明</a>.</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> pathLayer = <span class="type">CAShapeLayer</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">setPath</span><span class="params">(<span class="number">_</span> path: CGPath?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> animation = <span class="type">CABasicAnimation</span>(keyPath: <span class="string">"path"</span>)</span><br><span class="line">    animation.fromValue = pathLayer.presentationLayer!.path</span><br><span class="line">    animation.toValue = path</span><br><span class="line">    animation.duration = <span class="number">0.2</span></span><br><span class="line">    pathLayer.add(animation, forKey: <span class="string">"animatedPath"</span>)</span><br><span class="line">    pathLayer.path = path</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/// 动画调用</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyView</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">performAnimation</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="type">UIView</span>.animate(withDuration: <span class="number">0.2</span>) &#123;</span><br><span class="line">      <span class="keyword">self</span>.frame = <span class="comment">// new frame</span></span><br><span class="line">      <span class="keyword">self</span>.transform = <span class="comment">// new transform</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// option 1: setPath 写在 animation block 里</span></span><br><span class="line">      <span class="keyword">self</span>.setPath(<span class="comment">/* new path */</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// option 2: setPath 写在 animation block 外</span></span><br><span class="line">    <span class="keyword">self</span>.setPath(<span class="comment">/* new path */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而仅仅这么做会导致 view 和 layer 的 animation 无法同时作用</p><ul><li>有时候是出现了启动的时间差</li><li>有时候是一个 animation 吃掉了另一个 animation, UI 上出现突变而不是 2 个动画同时进行</li></ul><h3 id="解决办法"><a class="markdownIt-Anchor" href="#解决办法"></a> 解决办法</h3><p>考虑到 <code>UIView.animate()</code> 本质上就是依靠</p><ul><li><code>UIView</code> 设置自己成为 <code>self.layer</code> 的 <code>delegate</code>, 并且</li><li>在 animation block 调用期间, 针对不同的 property 变化通过 <code>CALayerDelegate</code> 中的 <code>action(for:forKey:)</code> 提供 implicit animation</li></ul><p>来实现的. 而既然 <code>UIView.animate()</code> 可以把一系列 animation 同时启动, 我们只需要也用类似的方式, 在同样的时刻提供 path 动画即可. 而想要参与 layer 的 implicit animation 的自定义过程, 有多种途径, 例如:</p><ul><li>实现自定义的 layer subclass, 重写 <code>defaultAction(forKey:)</code></li><li>给单独的 layer 增加 delegate, 重写 <code>action(for:forKey:)</code></li><li>实现自定义的 view subclass, 指定 <code>layerClass</code>, 并重写 <code>action(for:forKey:)</code></li></ul><p>等. 以下以单独增加 delegate 为例子.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> pathLayer = <span class="type">CAShapeLayer</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomLayerDelegate</span>: <span class="title">NSObject</span>, <span class="title">CALayerDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">action</span><span class="params">(<span class="keyword">for</span> layer: CALayer, forKey event: String)</span></span> -&gt; <span class="type">CAAction?</span> &#123;</span><br><span class="line">      <span class="keyword">guard</span> event == <span class="string">"path"</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">let</span> animation = <span class="type">CABasicAnimation</span>(keyPath: event)</span><br><span class="line">      animation.fromValue = layer.presentationLayer!.path</span><br><span class="line">      animation.toValue = path</span><br><span class="line">      animation.duration = <span class="number">0.2</span></span><br><span class="line">      <span class="keyword">return</span> animation</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> pathLayerDelegate = <span class="type">CustomLayerDelegate</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line">    pathLayer.delegate = pathLayerDelegate</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">setPath</span><span class="params">(<span class="number">_</span> path: CGPath?)</span></span> &#123;</span><br><span class="line">    pathLayer.path = path</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 动画调用</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyView</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">performAnimation</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="type">UIView</span>.animate(withDuration: <span class="number">0.2</span>) &#123;</span><br><span class="line">      <span class="keyword">self</span>.frame = <span class="comment">// new frame</span></span><br><span class="line">      <span class="keyword">self</span>.transform = <span class="comment">// new transform</span></span><br><span class="line">      <span class="keyword">self</span>.setPath(<span class="comment">/* new path */</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样每次在 <code>UIView.animate()</code> 的 animation block 中如果更改了 layer 的 <code>path</code>, 就会自动产生一个 implicit animation, 并且能和其他 view animation 并行产生作用.</p><h2 id="receive-swift-concurrency"><a class="markdownIt-Anchor" href="#receive-swift-concurrency"></a> Receive: Swift Concurrency</h2><p>关于 Swift 中新的并发编程特性的讨论已经在官方 forums <a href="https://forums.swift.org/t/concurrency-async-await-actors/6516" target="_blank" rel="noopener">持续好多年</a>了, 我个人也一直抱有浓厚的兴趣. 上周, Swift core team 终于正式以 <a href="https://forums.swift.org/t/swift-concurrency-roadmap/41611" target="_blank" rel="noopener">1 篇 road map</a> 和 4 篇 proposal 初稿隆重为各位 Swift 爱好者铺展开将会持续未来多个版本的道路. 虽然这些文档仍在积极讨论中, 和终稿相比想必会有很大的不同, 但我坚信, 相关的思想和观念将是一名优秀 Swifter 以后绕不开的宝库.</p><p>对于 iOS 开发者而言, 异步编程是再熟悉不过了, 平时日常开发中即使不涉及到多线程通信的问题, 也至少懂得&quot;繁琐操作不应该 block 主线程&quot;的道理. 而这次 Swift team 带来的 proposal 不但能免去我们开发者平时遇到的一些烦恼, 也能在更高的 level 上系统化地解决并发编程中的一些基本问题.</p><p>这里无法详述所有细节, 仅将相关 proposal 的主旨摘录于下:</p><ul><li><a href="https://github.com/DougGregor/swift-evolution/blob/async-await/proposals/nnnn-async-await.md" target="_blank" rel="noopener">Async/await</a> 为语言引入了一种新的 function: async function (包括 method).<ul><li>Async function 与普通 function 是两个世界, 无法互相调用, 只能在各自的 context 中调用.<ul><li>声明方式 <code>func asyncFunction(_ input: Int) async -&gt; Int</code> .</li><li>调用方式 <code>let result = await asyncFunction(10)</code>.</li></ul></li><li>Async function 调用后, 只能异步地返回.<ul><li>从语法角度, 可以认为 async function 是带 callback block 的普通 function 的语法糖.</li><li>从语义角度, async 是协程 (coroutine) 的应用: 在 async context 下每次 await, 都产生了断点, 当前协程中断, 直到被调用的 async function 异步完成时, 才会把返回值提供给 caller, caller 协程接着上次断点继续执行.</li></ul></li><li>Async function 可以极大简化普通 function 中因为大量使用 callback block 造成的书写问题, 例如:<ul><li>回调地狱——深层的 callback 嵌套.</li><li>数据流容易丢失——使用 callback 时编译器无法保证, 被调方法能一致地返回.</li><li>try catch 机制无法用于 callback 方法.</li></ul></li></ul></li><li>Async/await 只是引入了最基本的异步语法, 但日常应用需要有更高级的抽象. <a href="https://github.com/DougGregor/swift-evolution/blob/structured-concurrency/proposals/nnnn-structured-concurrency.md" target="_blank" rel="noopener">Structured concurrency</a> 在语言层面增加了许多机制.<ul><li>虽然 async function 异步执行, 但和普通 function 一样, 在执行过程中, 它与它内部所有 await 的操作也形成自然的树状&quot;父子&quot;结构, 系统可以保证所有子任务不会无故超越父任务的生命期.<ul><li>支持协作式的 cancellation: 任何子任务被 cancel, 父任务会同步自动进入 cancel 状态, 其他执行中的子任务也可以主动获取到 cancel 信息.</li><li>在一个任务中需要多个子任务并发处理的情况下:<ul><li>可以通过 <code>async let</code> binding 可以并发执行多个 async function, 并在同一的地方 await 多个任务的完成.</li><li>也可以通过 <code>Task.Nursery</code> 动态方式开始和结束任意数量的子任务.</li></ul></li></ul></li><li>在每一个 async function,中 都可以通过系统提供的 <code>Task</code> 类型, 实现许多并发机制.<ul><li>如上所说, <code>Task.Nursery</code> 可以动态并行开启子任务.</li><li>使用 <code>Task.isCancelled()</code> 等方法, 得知当前 task 是否被标记 cancelled.</li><li>使用 <code>Task.withDeadline()</code> 和 <code>Task.currentDeadline().remaining</code> 可以开启有时限的任务和检测时限是否已达.</li></ul></li><li><code>Task</code> 还可以联系 async 和 non-async 世界:<ul><li><code>Task.runDetached()</code> 允许我们从普通的非 async 代码进入一个 async context, 从而可以调用 async function.</li><li><code>Task.withUnsafeContinuation()</code> 允许从一个 async context 中临时转移到 non-async context, 执行我们的基于普通 callback block 的代码, 并等待回调.</li></ul></li></ul></li><li>上面 2 个 protocol 解决了并发编程中的一些效率问题, 而 <a href="https://github.com/DougGregor/swift-evolution/blob/actors/proposals/nnnn-actors.md" target="_blank" rel="noopener">Actors</a> 可以帮忙解决更困难和危险的问题——如何保证并发下的运行安全. 例如 data race, deadlock.<ul><li>引入了一种新的 type 类别: <code>actor class</code>.<ul><li>每一个 actor class 的实例对象, 背后都有一个 “queue” , 语言制定了一些列规则来保证所有该对象的方法默认都只能在该 queue 上执行, 并且当前 actor 的 value semantics 成员都不会被其他 actor 不安全地访问. 从而部分解决了 data race 问题.<ul><li>要访问的是 stored property 时, 只有当编译器能确保以下条件时,  才允许访问: 或者能保证该 property 是 immutable, 或者能保证访问只发生在 <code>self</code> 上.</li><li>要访问的是 non-async 方法时, 只允许在该 method 在 <code>self</code> 上调用, 不允许在别的对象上调用.</li><li>要访问的是 async 方法时, 没有限制. 而由于调用者只能异步等待返回, 因此解决了死锁问题.</li><li>当然针对不同情况, proposal 也提供了一些手段让开发者帮编译器作强制指定.</li></ul></li><li>对于全局方法, 虽然不在 actor class 内, 但可以给其标记属于某个 global actor, 所有的访问都等价于在这个 actor singleton 上执行.</li></ul></li><li>官方 forums 的 proposal 只针对 value semantics 的类型提供了检查, 而对其他类型的支持将会在以后加入. 这等于在以后版本加强了语言限制, 会导致现在 valid 的 code 以后某个版本不 valid.<ul><li>社区中针对这一问题, 许多大佬 (比如 Christ Lattner, Dave Abrahams) 提出了另一种策略: <a href="https://docs.google.com/document/d/1OMHZKWq2dego5mXQtWt1fm-yMca2qeOdCl8YlBG1uwg" target="_blank" rel="noopener">Protocol-based Actor Isolation</a>.</li><li>这个 proposal 里建议一开始就限制允许在不同 actor 接口间传递的数据的类型, 并允许标准库和开发者有办法让自己的类型满足要求.</li></ul></li></ul></li><li>最后, Swift 当前的首要用户必然是 ObjC 开发者, 而为 Swift 特性和 ObjC 交互也始终是首要任务之一. 因此将 async/await 甚至 actor 和 ObjC 打通也必然极有意义. <a href="https://github.com/DougGregor/swift-evolution/blob/concurrency-objc/proposals/NNNN-concurrency-objc.md" target="_blank" rel="noopener">Concurrency Interoperability with Objective-C</a> 就给这一块补上了许多支持.<ul><li>ObjC 中编写的基于 callback block 的方法, 在 bridge 到 Swift 时, 除了原有的 API, 符合条件时还会额外生成一个 async API.</li><li>Swift 中编写的 async API, 用 <code>@objc</code> 暴露给 ObjC 时, 会自动转换成 callback block 形式.</li><li>Swift 中编写的 actor class, 其 <code>@objc</code> 方法暴露给 ObjC 调用时, 会自动执行在对应 actor 的 “queue” 上.</li></ul></li></ul><h2 id="algorithm-substring-with-concatenation-of-all-words"><a class="markdownIt-Anchor" href="#algorithm-substring-with-concatenation-of-all-words"></a> Algorithm: Substring with Concatenation of All Words</h2><h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3><p>来自 <a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/" target="_blank" rel="noopener">leetcode</a>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</span><br><span class="line"> </span><br><span class="line">输入：</span><br><span class="line">  s = "barfoothefoobarman",</span><br><span class="line">  words = ["foo","bar"]</span><br><span class="line">输出：[0,9]</span><br><span class="line">解释：</span><br><span class="line">从索引 0 和 9 开始的子串分别是 "barfoo" 和 "foobar" 。</span><br><span class="line">输出的顺序不重要, [9,0] 也是有效答案。</span><br></pre></td></tr></table></figure><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><p>假设待匹配的每个 word 的宽度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>.<br>第一印象使用滑动窗口. 我们只检查字符串在滑动窗口中的部分, 是否是输入 words 的一个连接. 因为 words 都是等宽度的, 所以如果滑动窗口内的部分确实是连接, 那么按 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 为宽度进行划分后形成的 substring 集合, 必然等价于输入的 words 集合. 使用滑动窗口, 我们就可以一个字符一个字符地考察, 每增加一个字符, 可能产生新的 match.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// [  ] 对应 word 的宽度</span><br><span class="line"></span><br><span class="line">              |-新探测的字符</span><br><span class="line">              v</span><br><span class="line"> xxxxx.....xxxAxxx...</span><br><span class="line">  [  ][  ][  ] </span><br><span class="line">  ^          ^</span><br><span class="line">  |--window--|</span><br></pre></td></tr></table></figure><p>然而, 每次新增字符要检查滑动窗口部分是否 match 了所有的 word 是无需从窗口头部开始重新检查, 有很多数据是可以复用的. 只是这个复用并不是紧邻的, 也就是考察上一个字符时和和考察接下来的字符时, 并不能共享信息. 而是当前的滑动窗口状态和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 个字符前的状态有很大的相似性.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// [  ] 对应 word 的宽度</span><br><span class="line"></span><br><span class="line">  |--old window--|</span><br><span class="line">  [  ][  ][  ][  ]        &lt;- 之前可能的匹配</span><br><span class="line">  xxxxxxxxxxxxxxxxxxxx</span><br><span class="line">      [  ][  ][  ][  ]    &lt;- 移动 w 个字符后的匹配</span><br><span class="line">      |--new window--|</span><br></pre></td></tr></table></figure><p>因此, 可以拆分出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 个不同的 “赛道”, 不同的赛道之间 offset 为 1, 每个赛道仅在新增 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 个字符后才考察状态变化: 是否产生了新的匹配.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// [  ] 对应 word 的宽度</span><br><span class="line"></span><br><span class="line">   xxxxxxxxxxxxxxxxxxxx</span><br><span class="line">   [  ][  ][  ][  ]       &lt;- 赛道 0</span><br><span class="line">    [  ][  ][  ][  ]      &lt;- 赛道 1</span><br><span class="line">     [  ][  ][  ][  ]     &lt;- 赛道 2</span><br><span class="line">      [  ][  ][  ][  ]    &lt;- 赛道 3</span><br><span class="line">       [  ][  ][  ][  ]   &lt;- 赛道 0 (新增 w 字符后)</span><br></pre></td></tr></table></figure><p>如前所述, 每个赛道中上一次匹配的状态和下一次匹配的状态有很大的可复用性. 理论上, 只需要记录这个赛道中所有 substring 出现的次数, 每次新增/删除 substring 后, 检查各个 substring 的 count 是否和目标一致即可. 然而在具体的实现时, code 层面有办法做很大的优化, 避免真的遍历所有的 substring 的 count.</p><h3 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h3><p>首先实现一个 word 匹配器, 该匹配器做了优化, 使得检查输入的 words 是否正好和目标匹配, 能在短时间内完成. 为此, 在每次新增/删除 word 时, 多做了一些状态维护.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 存储待匹配的 word 及每个 word 目前的匹配情况</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleMultiSet</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// word: count</span></span><br><span class="line">  <span class="comment">/// &lt; 0 的 count 表示仍需一定数量的匹配</span></span><br><span class="line">  <span class="comment">/// &gt; 0 的 count 表示超出了匹配</span></span><br><span class="line">  <span class="comment">/// 不存在的 word 表示正好匹配</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> dict: [<span class="type">Substring</span>: <span class="type">Int</span>] = [:]</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 用待匹配的 words 初始化</span></span><br><span class="line">  <span class="keyword">init</span>(words: [<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words &#123;</span><br><span class="line">      dict[word[...], <span class="keyword">default</span>: <span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 新增加一个 candidate</span></span><br><span class="line">  <span class="comment">/// 理论上, 对应 word 的 count + 1</span></span><br><span class="line">  <span class="comment">/// 但当调整会导致 count == 0 时, 同时将 word 从 dict 里移除</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(<span class="number">_</span> word: Substring)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="built_in">count</span> = dict[word] &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">count</span> == -<span class="number">1</span> &#123;</span><br><span class="line">        dict[word] = <span class="literal">nil</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dict[word] = <span class="built_in">count</span> + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dict[word] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 去掉一个 candidate</span></span><br><span class="line">  <span class="comment">/// 理论上, 对应 word 的 count - 1</span></span><br><span class="line">  <span class="comment">/// 但当调整会导致 count == 0 时, 同时将 word 从 dict 里移除</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(<span class="number">_</span> word: Substring)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="built_in">count</span> = dict[word] &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">count</span> == <span class="number">1</span> &#123;</span><br><span class="line">        dict[word] = <span class="literal">nil</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dict[word] = <span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dict[word] = -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 检查是否所有初始的 word 都正好匹配完</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">verify</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dict.isEmpty</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此基础上根据上面的多赛道滑动窗口分析, 实现主算法.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Main entry point</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findSubstring</span><span class="params">(<span class="number">_</span> s: String, <span class="number">_</span> words: [String])</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="comment">/// early exit</span></span><br><span class="line">  <span class="keyword">if</span> words.isEmpty || words[<span class="number">0</span>].isEmpty &#123;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> wordSize = words[<span class="number">0</span>].<span class="built_in">count</span></span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">count</span> = words.<span class="built_in">count</span> * wordSize</span><br><span class="line">  <span class="keyword">if</span> s.<span class="built_in">count</span> &lt; <span class="built_in">count</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 根据 word 宽度决定当前的赛道个数</span></span><br><span class="line">  <span class="keyword">let</span> sets = (<span class="number">0</span>..&lt;wordSize).<span class="built_in">map</span> &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="type">SimpleMultiSet</span>(words: words) &#125;</span><br><span class="line">  <span class="comment">/// 当前赛道</span></span><br><span class="line">  <span class="keyword">var</span> setIndex = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 各个字符的 index</span></span><br><span class="line">  <span class="comment">// 当前 word start</span></span><br><span class="line">  <span class="keyword">var</span> i = s.startIndex</span><br><span class="line">  <span class="comment">// 当前 word end</span></span><br><span class="line">  <span class="keyword">var</span> j = s.index(i, offsetBy: wordSize)</span><br><span class="line">  <span class="comment">// 最旧的 word start</span></span><br><span class="line">  <span class="keyword">var</span> k = i</span><br><span class="line">  <span class="comment">// 最旧的 word end</span></span><br><span class="line">  <span class="keyword">var</span> l = j</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> stepper = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> setLoopCount = wordSize</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> results: [<span class="type">Int</span>] = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 增加初始的 word</span></span><br><span class="line">  sets[setIndex].push(s[i..&lt;j])</span><br><span class="line">  <span class="keyword">if</span> sets[setIndex].verify() &#123;</span><br><span class="line">    results.append(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> j != s.endIndex &#123;</span><br><span class="line">    <span class="comment">/// 每新增一个字符, 决定当前赛道</span></span><br><span class="line">    stepper += <span class="number">1</span></span><br><span class="line">    setIndex = (setIndex + <span class="number">1</span>) % setLoopCount</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 去掉超出窗口的 word</span></span><br><span class="line">    <span class="keyword">if</span> stepper &gt;= <span class="built_in">count</span> &#123;</span><br><span class="line">      sets[setIndex].remove(s[k..&lt;l])</span><br><span class="line">      s.formIndex(after: &amp;k)</span><br><span class="line">      s.formIndex(after: &amp;l)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/// 增加新的 word</span></span><br><span class="line">    s.formIndex(after: &amp;i)</span><br><span class="line">    s.formIndex(after: &amp;j)</span><br><span class="line">    sets[setIndex].push(s[i..&lt;j])</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 检查当前赛道是否正好匹配</span></span><br><span class="line">    <span class="keyword">if</span> sets[setIndex].verify() &#123;</span><br><span class="line">      results.append(stepper - <span class="built_in">count</span> + wordSize)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体上使用了 Swift <code>String</code> 的 index 和 <code>Substring</code> 操作避免产生不需要的 copy.</p><h3 id="性能分析"><a class="markdownIt-Anchor" href="#性能分析"></a> 性能分析</h3><p>假设有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个 word 待匹配, 每个 word 宽度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>, 输入字符串的长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>.</p><ul><li>时间上<ul><li>初始化阶段: 对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 个赛道每个都创建 <code>SimpleMultiSet</code>. 每次创建时 <code>SimpleMultiSet</code> 需要将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个 word 加入 dict, 考虑到 word 加入 dict 时的 hash 操作, 理论上会遍历 word 中的每个字符, 因此每次初始化耗时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>⋅</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k \cdot w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>. 因此初始化阶段总耗时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>⋅</mo><msup><mi>w</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k \cdot w^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</li><li>运行阶段: 是一个 main loop, 针对输入字符串中的字符循环 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>−</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">l - w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 次. 每次循环引入一个新的字符, 最多只需要从对应赛道的 <code>SimpleMultiSet</code> 中增加一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 长度的 substring, 并去掉一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 长度的 substring. 考虑到 word 加入和离开 dict 时的 hash 操作, 最多只需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>. 其他操作都可以在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 内完成, 所以总耗时为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>w</mi><mo>⋅</mo><mo stretchy="false">(</mo><mi>l</mi><mo>−</mo><mi>w</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(w \cdot (l - w))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>. 一般而言 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>≪</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">w \ll l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≪</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>, 因此可近似为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>w</mi><mo>⋅</mo><mi>l</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(w \cdot l)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span>.</li><li>总耗时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mo>⋅</mo><mi>w</mi><mo>+</mo><mi>k</mi><mo>⋅</mo><msup><mi>w</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(l \cdot w + k \cdot w^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>. 一般情况下, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>≪</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">k \ll l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≪</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>, 或可把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 视为常数, 此时总耗时为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mo>⋅</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(l \cdot w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>. 如果进一步把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 也视为常数, 则最终时间复杂度仅为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(l)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span>.</li></ul></li><li>空间上<ul><li>主要存储消耗为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 个赛道对应的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 个 <code>SimpleMultiSet</code> .</li><li>每个 <code>SimpleMultiSet</code> 最多时需要存储 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个宽度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 的substring. 简化来看, 如果把存储 substring 用的 dict 的装载因子视为常数, 则单个 dict 占用空间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>w</mi><mo>⋅</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(w \cdot k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>.</li><li>总占用空间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>⋅</mo><msup><mi>w</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k \cdot w^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, 如果把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 均视为常数, 那么整体空间复杂度仅为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>.</li></ul></li></ul><p><img src="/2020/tra-1/leetcode_record.png" alt="leetcode record"><br>(leetcode 上的耗时分析和 server 上的 Swift 版本有很大关系, 实际参考价值有限)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;ul class=&quot;markdownIt-TOC&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#tip-%E5%90%8C%E6%AD%A5-uiview-animation-%E5%92%8C-calayer-animation&quot;&gt;Tip: 同步 UIView animation 和 CALayer animation&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%97%AE%E9%A2%98%E6%9D%A5%E6%BA%90&quot;&gt;问题来源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95&quot;&gt;解决办法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#receive-swift-concurrency&quot;&gt;Receive: Swift Concurrency&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#algorithm-substring-with-concatenation-of-all-words&quot;&gt;Algorithm: Substring with Concatenation of All Words&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%A2%98%E7%9B%AE&quot;&gt;题目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%88%86%E6%9E%90&quot;&gt;分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%9E%E7%8E%B0&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90&quot;&gt;性能分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;TRA 是简化版的 &lt;a href=&quot;https://mp.weixin.qq.com/s/WMlApIA-v8zpB9l-VlMlyw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ARTS&lt;/a&gt;, 周期是两周一次。其中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;T 是 Tip, 总结和归纳日常中遇到的知识点.&lt;/li&gt;
&lt;li&gt;R 是 Receive, 新知识的输入(技术、理财、哲学、文化等)都算在内.&lt;/li&gt;
&lt;li&gt;A 是 Algorithm, 算法小练习.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="TRA" scheme="https://crystdragon.github.io/categories/tra/"/>
    
    
    <category term="Apple Platforms" scheme="https://crystdragon.github.io/tags/apple-platforms/"/>
    
    <category term="Swift Concurrency" scheme="https://crystdragon.github.io/tags/swift-concurrency/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI Notes</title>
    <link href="https://crystdragon.github.io/2020/swiftui-notes/"/>
    <id>https://crystdragon.github.io/2020/swiftui-notes/</id>
    <published>2020-08-02T16:00:00.000Z</published>
    <updated>2020-08-03T17:56:43.928Z</updated>
    
    <content type="html"><![CDATA[<p><ul class="markdownIt-TOC"><li><a href="#data-flow">Data Flow</a><ul><li><a href="#state">State</a><ul><li><a href="#state%E6%89%80%E6%8C%87%E7%A4%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E6%9C%9F"><code>State</code>所指示对象的生命期</a></li><li><a href="#state-wrapper-%E7%9A%84%E8%AF%AD%E6%B3%95%E7%89%B9%E5%BE%81"><code>State</code> wrapper 的语法特征</a></li></ul></li><li><a href="#observableobject">ObservableObject</a></li><li><a href="#observedobject">ObservedObject</a></li><li><a href="#stateobject-ios-14">StateObject (iOS 14+)</a><ul><li><a href="#%E8%AF%AD%E6%B3%95%E7%89%B9%E7%82%B9">语法特点</a></li></ul></li><li><a href="#binding">Binding</a></li></ul></li><li><a href="#framework-integration">Framework integration</a></li><li><a href="#ui-tips">UI Tips</a><ul><li><a href="#%E5%BE%85%E7%A1%AE%E8%AE%A4%E7%9A%84%E7%82%B9">待确认的点</a></li></ul></li></ul></p><hr><h2 id="data-flow"><a class="markdownIt-Anchor" href="#data-flow"></a> Data Flow</h2><h3 id="state"><a class="markdownIt-Anchor" href="#state"></a> State</h3><p>Property wrapper <code>State</code>只是一个映射, 并不真正开放空间存储变量, 真正的空间开辟是这样的过程:</p><ul><li><code>State</code>必须定义在某个<code>ViewA: View</code>中作为成员属性, 不能定义在别的地方, 也不能定义成optional, 也不能定义成static变量.</li><li>SwiftUI 在<code>ViewA</code>对象生成时, 通过某种和<code>DynamicProperty</code>相关的机制(<a href="https://medium.com/@kateinoigakukun/inside-swiftui-how-state-implemented-92a51c0cb5f6" target="_blank" rel="noopener">可能是某种 reflection 机制</a>, 也可能是 compiler synthesize), 根据<code>State</code>中指示的 initial value, 在真正的 <em>view</em><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 对象中建立了一份数据, 并把<code>ViewA</code>和其所有<code>State</code>的成员变量作出了 Model -&gt; View 的关联.</li><li>之后<code>ViewA.body</code>每次被重新调用 (例如 data change 导致的 update 或者 view 重新出现在屏幕上等) 前, 都会保证 <code>ViewA</code> 中可以访问到的值被更新到与内存中的运行时状态一致, 这样之后访问/操纵该值时, 本质上都是访问了对应的真正的与 view 关联的数据对象.</li><li>在 SwiftUI 可以监控到的环境下调用到某个<code>State</code>的 getter 的前提下, 我们只要在任何地方触发这个<code>State</code>的 setter, 就有可能触发获取了 getter 的<code>body</code>的重新调用.<ul><li>当<code>State</code> wrap 的类型是非<code>Equatable</code>时, 只要触发 setter, 即触发<code>body</code>被调用.</li><li>当<code>State</code> wrap 的类型遵循<code>Equatable</code>时, 只有触发 setter 时的<code>newValue</code>和旧值不同时, 才会触发<code>body</code>.</li></ul></li></ul><p>注意在非 SwiftUI 体系下, <code>State</code>毫无作用, 甚至基本的 get/set 逻辑都不满足.</p><h4 id="state所指示对象的生命期"><a class="markdownIt-Anchor" href="#state所指示对象的生命期"></a> <code>State</code>所指示对象的生命期</h4><p>无论是<code>State</code>, 还是我们自定义的<code>struct ViewA</code>, 本质上都只是 recipe, 不是真正的运行时对象. 真正的运行时对象, 要么被 SwiftUI 很好地隐藏在真正的 runtime view 对象中, 要么在我们自定义的别的 reference type 中(类似下文的ObservableObject).</p><a id="more"></a> <ul><li><code>State</code>指示的真正的对象的生命期和对应的 view 一致, 无论该 view 重绘几次, 只要没有从内存中清除, 都只初始化一次.</li><li>如果 parent view 刷新导致重新初始化了一个 child view 对应的 struct, 只要该 child view 在整个 view hierarchy 中的位置没有变化, SwiftUI 会很聪明地复用之前的 runtime 信息, 不会重新初始化<code>State</code>对应的数据对象.</li><li>如果这个 view 销毁再重新创建, 那么 SwiftUI 会用初始化值重新给新的 view 开辟一份.</li></ul><h4 id="state-wrapper-的语法特征"><a class="markdownIt-Anchor" href="#state-wrapper-的语法特征"></a> <code>State</code> wrapper 的语法特征</h4><ul><li>因为<code>State</code>的 setter 是<code>nonmutating</code>的, 因此:<ul><li>即使我们在<code>body</code>中 call 了 setter, 也无需把这个 struct 的<code>body</code>成员标记成<code>mutating</code>, 或者无需显示 capture 一个<code>var self</code>.</li><li>如果不用 property wrapper 的写法, 可以直接声明成<code>let xxx: State // (无需 var)</code>, 需要引用时, 使用使用<code>wrappedValue</code>的 setter/getter.</li></ul></li><li>因为<code>State</code>其实只是一个 wrapper, 不存储实际的 runtime value, 所以我们在 callback 中修改 struct 中的<code>State</code>对象时, 虽然从语法角度 block 必然会 capture 一份<code>self</code>, 导致修改的只是<code>State</code>副本, 但在 SwiftUI 系统中是 work 的.</li></ul><h3 id="observableobject"><a class="markdownIt-Anchor" href="#observableobject"></a> ObservableObject</h3><ul><li>一个 protocol, 供我们实现. 默认情况下, 如果变量有<code>@Published</code>, 那么 compiler 会自动帮我们实现需求的方法.</li><li>如果手动实现方法:<ul><li>则必须实现一个<code>Publisher</code>类型的成员<code>objectWillChange</code>, 其<code>Failure == Never</code>. 一般可以直接用<code>ObservableObjectPublisher</code>这个 concrete type.</li><li>SwiftUI 会在合适的时候给这个 publisher 增加 subscriber.</li><li>要求我们的 code 在合适的时机(必须符合 “will” 的语义)通过<code>objectWillChange</code>发出信息.</li></ul></li><li>SwiftUI中的<code>@ObservedObject</code>可以将<code>ObservableObject</code>用 property wrapper 包装. .</li><li>SwiftUI中的<code>@EnvironmentObject</code>同样可以包装<code>ObservableObject</code>.</li></ul><h3 id="observedobject"><a class="markdownIt-Anchor" href="#observedobject"></a> ObservedObject</h3><p>一个 property wrapper, 包装遵循<code>ObservableObject</code>的对象. 类似<code>State</code>使用, 但和<code>State</code>有区别.</p><ul><li>设定成<code>View</code>的成员变量后, 和<code>State</code>类似, SwiftUI 会建立 model 和 view 之间的联系. 但是, 只要这个<code>ObservableObject</code>的<code>objectWillChange</code>发出信息, 则<code>body</code>就会被重新调用, <em>不需要在 SwiftUI 可以监控到的环境下首先被调用过 getter</em>.</li><li>这个<code>ObservedObject</code>成员对象的内存生命期不和 runtime view 一一绑定, 而是由我们的 code 控制<ul><li>如果这个 property 使用 dependency injection 由外部传入, 那么只要外部的引用不消亡, 则始终是同一份对象.</li><li>如果这个 property 是在当前 struct 中初始化, 那么该对象的生命期和当前 struct 被初始化和 pass-by-value 的范围有关.<ul><li>如果只是当前 view 被重绘, 触发<code>body</code>重新调用, 那么这个对象仍然存活.</li><li>如果是 parent view 被重绘, 触发初始化一个新的 child view struct, 那么旧的<code>View</code>对象所有引用计数终会清空, 而新的 view 用到的<code>ObservedObject</code>和旧的完全无关.</li></ul></li></ul></li></ul><h3 id="stateobject-ios-14"><a class="markdownIt-Anchor" href="#stateobject-ios-14"></a> StateObject (iOS 14+)</h3><p>一个 property wrapper, 综合了<code>State</code>和<code>ObservedObject</code>的特点:</p><ul><li>包含的对象是自定义的遵循了<code>ObservableObject</code>的类型.</li><li>对象的生命期和 runtime view 保持一致.</li></ul><p>待确认的点:</p><ul><li>是否需要 getter 在<code>body</code>中被调用的前提, 才能在<code>objectWillChange</code>产生信息时触发<code>body</code>. 即是类似<code>ObservedObject</code>, 还是类似<code>State</code>?</li></ul><h4 id="语法特点"><a class="markdownIt-Anchor" href="#语法特点"></a> 语法特点</h4><ul><li><code>StateObject</code> wrapper 的初始化方法是一个<code>@autoclosure</code>, 这意味着和<code>State</code>、<code>ObservedObject</code>均不同: 只有当对应 view 要被渲染时 初始值表达式才会被求值, 而非 view struct 被初始化时.</li></ul><h3 id="binding"><a class="markdownIt-Anchor" href="#binding"></a> Binding</h3><ul><li>一个 property wrapper, 包装一个 setter/getter 对.</li><li>可以从<code>State</code>, <code>ObservedObject</code>等对象通过<code>$</code>前缀 + keypath 导出.</li><li>一般<code>State</code>包裹的泛型类型是一个 struct, 所以只要局部有变化, 整体即产生变化. 因此, 即使用<code>$</code>运算生成部分 key path 的<code>Binding</code>, 只要部分值变化, 就会触发<em>所有</em>引用到<code>State</code> getter 或关联的<code>Binding</code> 的 view 进行重新获取<code>body</code>.</li></ul><h2 id="framework-integration"><a class="markdownIt-Anchor" href="#framework-integration"></a> Framework integration</h2><ul><li>把 SwiftUI 放入 UIKit: <code>UIHostingController</code>, 一个<code>UIViewController</code>的 concrete 子类.</li><li>把 UIKit 放入 SwiftUI: <code>UIViewControllerRepresentable</code>和<code>UIViewRepresentable</code>.<ul><li>两者都遵循<code>View</code>, 并对所有<code>View</code>要求的方法进行了默认实现</li><li>基本要求遵循者<ul><li>提供初始的<code>UIViewController</code>/<code>UIView</code>.</li><li>基于当前 model 进行 view update.</li></ul></li><li>该 view 初次展现时, 系统会根据<code>Coordinator</code> associated type 实现创建并维持一个 coordinator, 在初始化和 update 时作为参数提供给核心 protocol 的实现者. 使实现者可以完成一些 binding.</li><li>最常见的 model 驱动顺序为:<ul><li>创建 protocol 遵循者的实例时, 将 model dependency (例如<code>Binding</code>) 传入.</li><li>第一次渲染前, 系统创建 coordinator, 可以把 protocol 遵循者本体 inject 到这个 coordinator 中. 同时使 coordinator 实现 UIKit 中的一些 event pattern.</li><li>在创建实际的 vc/view 时, 系统会把早前实例的 coordinator 传递给 protocol 的遵循者, 并在这里完成 event 的绑定.</li><li>当发生 UIKit 体系内的 event 时, 触发 coordinator 中的回调, 进而在 coordinator 中操纵 injected model dependency.</li><li>SwiftUI 触发所有引用到 <code>@State</code> 的 view 的变化, 包括核心 protocol 遵循者的 update 方法.</li></ul></li></ul></li></ul><h2 id="ui-tips"><a class="markdownIt-Anchor" href="#ui-tips"></a> UI Tips</h2><p>SwiftUI 毕竟和之前熟悉的 UIKit 是2套 API. 这里记录一些琐碎的 UI 相关实现 tips.</p><ul><li>实现 navigation: 把<code>NavigationLink</code>放到<code>NavigationView</code>.</li><li>实现 presentation: <code>.sheet()</code>.</li><li>不通过 click/tap gesture 实现<code>navigation</code>的 callback, 可以通过<code>isActive</code>参数, 传入一个自定义的<code>ObservableObject</code>对象, 就可以实现对子页面是否显示的监听.</li></ul><h3 id="待确认的点"><a class="markdownIt-Anchor" href="#待确认的点"></a> 待确认的点</h3><ul><li><code>Scene</code>和<code>View</code>的<code>onChange</code>方法, 传入 value 是怎么 work 的.</li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>本文所有单独出现的 view, 都指真正的 runtime 对象, 和<code>View</code>或 <em>view struct</em> 含义有区别, 后者仅仅是 recipe/description. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;ul class=&quot;markdownIt-TOC&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#data-flow&quot;&gt;Data Flow&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#state&quot;&gt;State&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#state%E6%89%80%E6%8C%87%E7%A4%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E6%9C%9F&quot;&gt;&lt;code&gt;State&lt;/code&gt;所指示对象的生命期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#state-wrapper-%E7%9A%84%E8%AF%AD%E6%B3%95%E7%89%B9%E5%BE%81&quot;&gt;&lt;code&gt;State&lt;/code&gt; wrapper 的语法特征&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#observableobject&quot;&gt;ObservableObject&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#observedobject&quot;&gt;ObservedObject&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#stateobject-ios-14&quot;&gt;StateObject (iOS 14+)&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%AF%AD%E6%B3%95%E7%89%B9%E7%82%B9&quot;&gt;语法特点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#binding&quot;&gt;Binding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#framework-integration&quot;&gt;Framework integration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#ui-tips&quot;&gt;UI Tips&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%BE%85%E7%A1%AE%E8%AE%A4%E7%9A%84%E7%82%B9&quot;&gt;待确认的点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;data-flow&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#data-flow&quot;&gt;&lt;/a&gt; Data Flow&lt;/h2&gt;
&lt;h3 id=&quot;state&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#state&quot;&gt;&lt;/a&gt; State&lt;/h3&gt;
&lt;p&gt;Property wrapper &lt;code&gt;State&lt;/code&gt;只是一个映射, 并不真正开放空间存储变量, 真正的空间开辟是这样的过程:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;State&lt;/code&gt;必须定义在某个&lt;code&gt;ViewA: View&lt;/code&gt;中作为成员属性, 不能定义在别的地方, 也不能定义成optional, 也不能定义成static变量.&lt;/li&gt;
&lt;li&gt;SwiftUI 在&lt;code&gt;ViewA&lt;/code&gt;对象生成时, 通过某种和&lt;code&gt;DynamicProperty&lt;/code&gt;相关的机制(&lt;a href=&quot;https://medium.com/@kateinoigakukun/inside-swiftui-how-state-implemented-92a51c0cb5f6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;可能是某种 reflection 机制&lt;/a&gt;, 也可能是 compiler synthesize), 根据&lt;code&gt;State&lt;/code&gt;中指示的 initial value, 在真正的 &lt;em&gt;view&lt;/em&gt;&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn1&quot; id=&quot;fnref1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; 对象中建立了一份数据, 并把&lt;code&gt;ViewA&lt;/code&gt;和其所有&lt;code&gt;State&lt;/code&gt;的成员变量作出了 Model -&amp;gt; View 的关联.&lt;/li&gt;
&lt;li&gt;之后&lt;code&gt;ViewA.body&lt;/code&gt;每次被重新调用 (例如 data change 导致的 update 或者 view 重新出现在屏幕上等) 前, 都会保证 &lt;code&gt;ViewA&lt;/code&gt; 中可以访问到的值被更新到与内存中的运行时状态一致, 这样之后访问/操纵该值时, 本质上都是访问了对应的真正的与 view 关联的数据对象.&lt;/li&gt;
&lt;li&gt;在 SwiftUI 可以监控到的环境下调用到某个&lt;code&gt;State&lt;/code&gt;的 getter 的前提下, 我们只要在任何地方触发这个&lt;code&gt;State&lt;/code&gt;的 setter, 就有可能触发获取了 getter 的&lt;code&gt;body&lt;/code&gt;的重新调用.
&lt;ul&gt;
&lt;li&gt;当&lt;code&gt;State&lt;/code&gt; wrap 的类型是非&lt;code&gt;Equatable&lt;/code&gt;时, 只要触发 setter, 即触发&lt;code&gt;body&lt;/code&gt;被调用.&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;State&lt;/code&gt; wrap 的类型遵循&lt;code&gt;Equatable&lt;/code&gt;时, 只有触发 setter 时的&lt;code&gt;newValue&lt;/code&gt;和旧值不同时, 才会触发&lt;code&gt;body&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意在非 SwiftUI 体系下, &lt;code&gt;State&lt;/code&gt;毫无作用, 甚至基本的 get/set 逻辑都不满足.&lt;/p&gt;
&lt;h4 id=&quot;state所指示对象的生命期&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#state所指示对象的生命期&quot;&gt;&lt;/a&gt; &lt;code&gt;State&lt;/code&gt;所指示对象的生命期&lt;/h4&gt;
&lt;p&gt;无论是&lt;code&gt;State&lt;/code&gt;, 还是我们自定义的&lt;code&gt;struct ViewA&lt;/code&gt;, 本质上都只是 recipe, 不是真正的运行时对象. 真正的运行时对象, 要么被 SwiftUI 很好地隐藏在真正的 runtime view 对象中, 要么在我们自定义的别的 reference type 中(类似下文的ObservableObject).&lt;/p&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://crystdragon.github.io/categories/notes/"/>
    
    <category term="Apple Platforms" scheme="https://crystdragon.github.io/categories/apple-platforms/"/>
    
    
    <category term="SwiftUI" scheme="https://crystdragon.github.io/tags/swiftui/"/>
    
  </entry>
  
  <entry>
    <title>Testing in Xcode</title>
    <link href="https://crystdragon.github.io/2020/testing-in-xcode/"/>
    <id>https://crystdragon.github.io/2020/testing-in-xcode/</id>
    <published>2020-08-01T16:00:00.000Z</published>
    <updated>2020-08-02T11:08:33.444Z</updated>
    
    <content type="html"><![CDATA[<p><ul class="markdownIt-TOC"><li><a href="#async-testing">Async Testing</a></li><li><a href="#attachments">Attachments</a></li><li><a href="#code-coverage">Code Coverage</a></li><li><a href="#%E7%BC%96%E5%86%99-unit-test-%E7%9A%84-best-practices">编写 Unit Test 的 Best Practices</a><ul><li><a href="#codeapi-%E7%BB%86%E8%8A%82">code/API 细节</a></li><li><a href="#%E9%9A%94%E7%A6%BB-dependency">隔离 Dependency</a></li><li><a href="#%E5%9C%A8-xcode-%E6%89%A7%E8%A1%8C-test-%E7%9A%84%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7">在 Xcode 执行 test 的操作技巧</a></li></ul></li><li><a href="#test-plans">Test Plans</a></li><li><a href="#ci-%E7%9B%B8%E5%85%B3">CI 相关</a></li></ul></p><hr><p>References:</p><ul><li><a href="https://developer.apple.com/videos/play/wwdc2017/409/" target="_blank" rel="noopener">What’s New in Testing</a>, WWDC 2017, Session 409<ul><li>异步 testing API 的变化</li><li>UI Test 支持多 App test</li><li>UI Test 的 query 性能优化 (需要 programmer 介入)</li><li>Attachments</li></ul></li><li><a href="https://developer.apple.com/videos/play/wwdc2018/403/" target="_blank" rel="noopener">What’s New in Testing</a>, WWDC 2018, Session 403<ul><li>Code coverage 优化</li><li>Xcode 新的 Testing 选项</li><li>支持并行执行 test</li></ul></li><li><a href="https://developer.apple.com/videos/play/wwdc2018/417/" target="_blank" rel="noopener">Testing Tips &amp; Tricks</a>, WWDC 2018, Session 417<ul><li>编写 test case 的 best practics</li></ul></li><li><a href="https://developer.apple.com/videos/play/wwdc2019/413/" target="_blank" rel="noopener">Testing in Xcode</a>, WWDC 2019, Session 413<ul><li>review <code>XCTest</code> 基本功能</li><li>新增 Test Plans</li><li>CI 支持综述</li></ul></li></ul><hr> <a id="more"></a><h2 id="async-testing"><a class="markdownIt-Anchor" href="#async-testing"></a> Async Testing</h2><ul><li><code>XCTestExpectation</code>表示一个异步任务, 创建即表示任务开始执行, 需要在特定时机<code>fulfill</code>.<ul><li>早期只能通过<code>XCTestCase</code>的 method 创建, 且在一个 test 中, 创建后必须完成, 否则此 case 即失败.</li><li>新 API 可以独立创建 expectation.</li><li>通过<code>XCTestCase</code>的<code>wait</code>方法检测完成情况.</li></ul></li><li><code>XCTWaiter</code> 把异步任务执行结果的检验从<code>XCTestCase</code>中抽离出来.<ul><li>可以注入 delegate, 考察<code>wait</code>方法的返回值来作更精细的检验.</li><li>默认情况下, 不管是什么 result 都不会触发 test failure.</li></ul></li></ul><h2 id="attachments"><a class="markdownIt-Anchor" href="#attachments"></a> Attachments</h2><ul><li><code>XCTContext</code>的<code>runActivity</code>方法可以在 report 中产生一个 block, 用来把一些 test 示例组合到一起.</li><li>Activity 的功能之一是给 report 增加<code>XCTAttachment</code><ul><li><code>XCTAttachment</code>默认清除逻辑是成功清除, 失败不清除, 此默认行为可以在scheme中更改.</li><li>每个attachment还可以强制设置<code>lifetime</code>变更行为.</li></ul></li><li>不使用 Xcode GUI 提取attachment, 需要用到<em>xcresulttool</em>这个 tool (Xcode11开始).<ul><li>待检测的文件根目录位于 DerivedData 文件夹中, 一般为&quot;DerivedData/$PRODUCT_NAME-xxxxxxxxxx&quot;(非DerivedData/Build).</li><li>子路径为&quot;Logs/Test&quot;, 文件后缀一定是&quot;xcresult&quot;.</li><li>参考<a href="https://developer.apple.com/documentation/xcode_release_notes/xcode_11_release_notes?language=objc" target="_blank" rel="noopener">官方 release notes</a>,  命令为<code>xcrun xcresulttool get --format json --path ./Example.xcresult</code>, 可以通过追加<code>--id REF</code>输出子 object.</li><li>一个 attachment 是 string 的例子: Root -&gt; testsRef(–id) -&gt; summaryRef(–id) -&gt; attachments/payloadRef -&gt; 目标 string data 的文件名(实际路径为 Data/data.$id, 可以用 export 命令导出)</li></ul></li><li>官方格式非常复杂, 可以用第三方 tool<a href="https://github.com/ChargePoint/xcparse" target="_blank" rel="noopener">xcparse</a>, 这是其<a href="https://www.chargepoint.com/engineering/xcparse/" target="_blank" rel="noopener">介绍文章</a>.</li></ul><h2 id="code-coverage"><a class="markdownIt-Anchor" href="#code-coverage"></a> Code Coverage</h2><ul><li>可以在 Xcode 配置.<ul><li>要统计 coverage 的代码来自哪些 target</li><li>设定每个 target 中新写的 test case 是否自动 enable</li><li>每个 class 中的 tests 是否乱序执行</li><li>是否并行执行不同的 class<ul><li><code>xcodebuild -parallel-testing-worker-count</code> 可更改.</li><li>除了 mac 上的 UITest 外, 都支持(simulator 或 unit test).</li></ul></li></ul></li><li>命令行 tool: <code>xccov</code>.<ul><li>处理&quot;.xccovreport&quot;文件, Xcode 11之前.</li><li>含 code coverage 信息的&quot;.xcresult&quot;文件, Xcode 11+.</li></ul></li></ul><h2 id="编写-unit-test-的-best-practices"><a class="markdownIt-Anchor" href="#编写-unit-test-的-best-practices"></a> 编写 Unit Test 的 Best Practices</h2><h3 id="codeapi-细节"><a class="markdownIt-Anchor" href="#codeapi-细节"></a> code/API 细节</h3><ul><li>所有 test methods 支持定义成<code>throws</code>.</li><li><code>XCTNSPredicateExpectation</code>是依照轮询机制实现的, 可能较慢, 优先用其他<code>Expectation</code>.</li><li><code>XCTSkipIf</code>系方法可以跳过当前 case, 并且后续代码不执行, 在 result 中会标记成 skipped.</li><li><code>XCTUnwrap</code> 专用于 unwrap optional.</li><li><code>XCTAssertThrowsError</code> 专用于 catch error.</li></ul><h3 id="隔离-dependency"><a class="markdownIt-Anchor" href="#隔离-dependency"></a> 隔离 Dependency</h3><p>当某一个模块我们需要单独测试, 但是该模块有关联的外部对象时, 如何编写测试 code.</p><ul><li>如果外部依赖提供了 framework 层面的机制, 允许我们替换一部分逻辑, 则可以编写 code 安插到体系中/<ul><li>Network 相关: 官方的<code>URLSession</code>支持初始化单个对象, 可以独立设置 custom<code>URLProtocol</code>来提供 mock 数据.</li><li>Notification相关: 为了防止被其他 code 干扰, 官方的<code>NotificationCenter</code>支持初始化单个对象.</li></ul></li><li>如果体系本身不支持, 那么我们可以将依赖到的不可控的外部类抽象成protocol.<ul><li>配合 dependency injection, 把 protocol 类型的对象作为待测试组件初始化时的输入.</li><li>在生产环境 code 中, 将实际的外部类遵循这个 protocol; 而在 test 环境中编写一个临时的该 protocol 遵循者来 mock 行为.</li><li>当外部依赖和待测试组件之间的关系比较复杂的时候(比如有某种更深层次的依赖: 外部依赖对应的某个 delegate method 需要引用到与外部依赖同样 type 的对象, 从而导致 mock 方不仅仅需要 mock 外部依赖抽出的 protocol, 还要把这个 delegate 进一步抽象), 需要同时抽象外部依赖中多个层面的类型, 必要时候还需要依赖 type 强转.</li><li>当涉及到耗时较久的异步机制时, 我们可以把异步机制抽象出来. 在生产环境 code 中, 使用实际的异步流程; 在 test 环境中使用顺序流程.</li></ul></li></ul><h3 id="在-xcode-执行-test-的操作技巧"><a class="markdownIt-Anchor" href="#在-xcode-执行-test-的操作技巧"></a> 在 Xcode 执行 test 的操作技巧</h3><ul><li>Source editor 中的菱形按钮 control-click 可以 jump to report.</li><li>可以在 test navigator 中 command click 选择多个 case.</li><li>菜单 Product/Perform -&gt; Action 中可以进行特殊的 test 操作 (例如重复刚才的 test).</li></ul><h2 id="test-plans"><a class="markdownIt-Anchor" href="#test-plans"></a> Test Plans</h2><p>对某个 target 执行 test 时, 可以调整不同的运行参数/选项进行多次 test.</p><ul><li>Xcode 基本操作支持<ul><li>scheme editor 中把 test 升级成 test plan.</li><li>可以在 test navigator 中 control-click, 选择执行 plan 中某个特定的 test 配置.</li></ul></li><li>支持调整的参数主要有:<ul><li>launch arguments &amp; environment vairables</li><li>language</li><li>Xcode runtime Sanitizers, diagnostics &amp; checker (允许重新编译)</li><li>test 选项</li></ul></li><li>多个 scheme 可以重复引用同一个 test plan.</li><li>一个 scheme 可以包含多个 test plan, 其中一个为 default.<ul><li>默认执行 test 时, 使用 default test plan, 也可以在 test navigator 中切换.</li><li>在使用命令行时, 可以通过 <code>xcodebuild -showTestPlans</code> 查看所有该 scheme 的 test plan,  <code>xcodebuild test -testPlan</code> 选择 plan.</li></ul></li></ul><h2 id="ci-相关"><a class="markdownIt-Anchor" href="#ci-相关"></a> CI 相关</h2><p>一个 project 进入 CI server 后典型的流程有:</p><ol><li>编译&amp;测试工程. 核心命令<code>xcodebuild</code><ul><li><code>xcodebuild test</code> : 整体执行某个 target 的 test 动作</li><li><code>xcodebuild build-for-testing</code>: 只 build 不 test, 生成&quot;.xctestrun&quot;文件. 文件格式是 property list, 具体说明见<code>man xcodebuild.xctestrun</code>命令.</li><li><code>xcodebuild test-without-building -xctestrun xxx.xctestrun</code>: 单独test.</li><li>最后2步可以分离.</li><li><code>-resultBundlePath xxx.xcresult</code>: 可以指定 test 的结果用于后续步骤.</li></ul></li><li>解析 test 结果, 从而输出 log/自动建立 bug.<ul><li><code>xcrun xcresulttool</code> 需要输入 xcresult 文件, 解析 test result, 获取 attachment 等.</li></ul></li><li>检查 code coverage<ul><li><code>xcrun xccov --report</code>: 需要输入 xcresult 文件, Xcode 11+.</li><li><code>xcrun xccov</code>: 需要输入 xccovreport 文件.</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;ul class=&quot;markdownIt-TOC&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#async-testing&quot;&gt;Async Testing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#attachments&quot;&gt;Attachments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#code-coverage&quot;&gt;Code Coverage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%BC%96%E5%86%99-unit-test-%E7%9A%84-best-practices&quot;&gt;编写 Unit Test 的 Best Practices&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#codeapi-%E7%BB%86%E8%8A%82&quot;&gt;code/API 细节&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%9A%94%E7%A6%BB-dependency&quot;&gt;隔离 Dependency&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%9C%A8-xcode-%E6%89%A7%E8%A1%8C-test-%E7%9A%84%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7&quot;&gt;在 Xcode 执行 test 的操作技巧&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#test-plans&quot;&gt;Test Plans&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#ci-%E7%9B%B8%E5%85%B3&quot;&gt;CI 相关&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;References:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2017/409/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;What’s New in Testing&lt;/a&gt;, WWDC 2017, Session 409
&lt;ul&gt;
&lt;li&gt;异步 testing API 的变化&lt;/li&gt;
&lt;li&gt;UI Test 支持多 App test&lt;/li&gt;
&lt;li&gt;UI Test 的 query 性能优化 (需要 programmer 介入)&lt;/li&gt;
&lt;li&gt;Attachments&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2018/403/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;What’s New in Testing&lt;/a&gt;, WWDC 2018, Session 403
&lt;ul&gt;
&lt;li&gt;Code coverage 优化&lt;/li&gt;
&lt;li&gt;Xcode 新的 Testing 选项&lt;/li&gt;
&lt;li&gt;支持并行执行 test&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2018/417/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Testing Tips &amp;amp; Tricks&lt;/a&gt;, WWDC 2018, Session 417
&lt;ul&gt;
&lt;li&gt;编写 test case 的 best practics&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2019/413/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Testing in Xcode&lt;/a&gt;, WWDC 2019, Session 413
&lt;ul&gt;
&lt;li&gt;review &lt;code&gt;XCTest&lt;/code&gt; 基本功能&lt;/li&gt;
&lt;li&gt;新增 Test Plans&lt;/li&gt;
&lt;li&gt;CI 支持综述&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://crystdragon.github.io/categories/notes/"/>
    
    <category term="Apple Platforms" scheme="https://crystdragon.github.io/categories/apple-platforms/"/>
    
    
    <category term="Testing" scheme="https://crystdragon.github.io/tags/testing/"/>
    
    <category term="Xcode" scheme="https://crystdragon.github.io/tags/xcode/"/>
    
  </entry>
  
  <entry>
    <title>Pointfree.co Notes Ep.#23-25</title>
    <link href="https://crystdragon.github.io/2020/pointfree-co-notes-ep-23-25/"/>
    <id>https://crystdragon.github.io/2020/pointfree-co-notes-ep-23-25/</id>
    <published>2020-07-30T11:17:12.000Z</published>
    <updated>2020-07-30T11:54:51.930Z</updated>
    
    <content type="html"><![CDATA[<p><ul class="markdownIt-TOC"><li><a href="#%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84-zip">最常见的 zip</a><ul><li><a href="#swift-%E6%8F%90%E4%BE%9B%E7%9A%84-zip">Swift 提供的 zip</a></li></ul></li><li><a href="#%E9%80%9A%E7%94%A8%E7%9A%84%E4%BA%8C%E5%85%83-zip">通用的二元 zip</a></li><li><a href="#%E5%A4%9A%E5%85%83-zip">多元 zip</a></li><li><a href="#zip%E5%92%8Cmap%E7%9A%84%E8%81%94%E7%B3%BB"><code>zip</code>和<code>map</code>的联系</a></li></ul></p><p>这里记录了 <a href="http://pointfree.co" target="_blank" rel="noopener">pointfree.co</a> 上, 以下三期视频的 notes:</p><ul><li><a href="https://www.pointfree.co/episodes/ep23-the-many-faces-of-zip-part-1" target="_blank" rel="noopener">Ep #23. The Many Faces of Zip: Part 1</a></li><li><a href="https://www.pointfree.co/episodes/ep24-the-many-faces-of-zip-part-2" target="_blank" rel="noopener">Ep #24. The Many Faces of Zip: Part 2</a></li><li><a href="https://www.pointfree.co/episodes/ep25-the-many-faces-of-zip-part-3" target="_blank" rel="noopener">Ep #25. The Many Faces of Zip: Part 3</a></li></ul><hr><p>zip的本质: 一个映射</p><h2 id="最常见的-zip"><a class="markdownIt-Anchor" href="#最常见的-zip"></a> 最常见的 zip</h2><p>考虑显然存在这样的映射<code>A, B -&gt; (A, B)</code>. 那么对任意一个包含<code>T</code>的结构<code>Struct&lt;T&gt;</code>, 我们一定可以给出映射<code>g: Struct&lt;A&gt; , Struct&lt;B&gt; -&gt; Struct&lt;(A, B)&gt;</code>. 这样的映射<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>就是<code>zip</code>.</p><p>这里的<code>Struct</code>可以是 Swift 中的许多有意义的结构, 比如:</p><ul><li>Optional</li><li>Array</li><li>function</li><li>callback function</li><li>任意有&quot;包含&quot;关系的 plain structure</li></ul><p>例如, 针对<code>Optional</code>, 我们可以实现</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zip</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> lhs: Optional&lt;A&gt;, <span class="number">_</span> rhs: Optional&lt;B&gt;)</span></span> -&gt; <span class="type">Optional</span>&lt;(<span class="type">A</span>, <span class="type">B</span>)&gt; &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> a = lhs, <span class="keyword">let</span> b = rhs <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">  <span class="keyword">return</span> .some((a, b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>又例如, 针对 function: <code>() -&gt; T</code>, 我们可以实现</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Function</span>&lt;<span class="type">T</span>&gt; = () -&gt; <span class="type">T</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zip</span>&lt;A, B&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="number">_</span> lhs: @escaping Function&lt;A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="number">_</span> rhs: @escaping Function&lt;B&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> -&gt; <span class="type">Function</span>&lt;(<span class="type">A</span>, <span class="type">B</span>)&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    (lhs(), rhs())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="swift-提供的-zip"><a class="markdownIt-Anchor" href="#swift-提供的-zip"></a> Swift 提供的 zip</h3><p>在标准库中<code>zip(Sequence&lt;A&gt;, Sequence&lt;B&gt;) -&gt; Sequence&lt;(A, B)&gt;</code>就是一个通用的例子. (实为伪代码, 实际上 return type 是一个 concrete type)</p><p>第一方许多 framework 也提供了 zip. 例如: Combine 给许多遵循<code>Publisher</code>的 concrete type, 增加了成员方法, 结构为<code>Publisher&lt;A&gt;.zip(Publisher&lt;B&gt;) -&gt; Publisher&lt;(A, B)&gt;</code>. (实为伪代码, 方法所在的类型和 return type 都是 concrete type, 泛型参数也稍有不同)</p><h2 id="通用的二元-zip"><a class="markdownIt-Anchor" href="#通用的二元-zip"></a> 通用的二元 zip</h2><p>给定一个映射<code>f: (A, B) -&gt; C</code>,  对任意一个包含<code>T</code>的结构<code>Struct&lt;T&gt;</code>, 我们一定可以给出映射<code>g: (Struct&lt;A&gt; , Struct&lt;B&gt;) -&gt; Struct&lt;C&gt;</code>.</p><p>例如, 针对 callback function: <code>((T) -&gt; Void) -&gt; Void</code>的例子:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定 f</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>&lt;A, B, C&gt;<span class="params">(<span class="number">_</span> lhs: A, <span class="number">_</span> rhs: B)</span></span> -&gt; <span class="type">C</span> &#123; <span class="built_in">fatalError</span>() &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>&lt;A, B, C&gt;<span class="params">(<span class="number">_</span> lhs: A, <span class="number">_</span> rhs: B)</span></span> -&gt; <span class="type">C</span> &#123; <span class="built_in">fatalError</span>() &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zip</span>&lt;A, B, C&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="number">_</span> lhs: @escaping CallbackFunction&lt;A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="number">_</span> rhs: @escaping CallbackFunction&lt;B&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> -&gt; <span class="type">CallbackFunction</span>&lt;<span class="type">C</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; callback <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">var</span> lValue: <span class="type">A?</span></span><br><span class="line">    <span class="keyword">var</span> rValue: <span class="type">B?</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> lValue = lValue, <span class="keyword">let</span> rValue = rValue <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">      callback(f(lValue, rValue))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    lhs &#123; returnValue <span class="keyword">in</span></span><br><span class="line">      lValue = returnValue</span><br><span class="line">      check()</span><br><span class="line">    &#125;</span><br><span class="line">    rhs &#123; returnValue <span class="keyword">in</span></span><br><span class="line">      rValue = returnValue</span><br><span class="line">      check()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有时候称<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>是 zip, 上文常见 zip 是这种定义下的一个特例, 即指定了<code>f(A, B) = (A, B)</code>.</li><li>有时候称<code>f-&gt;g</code> 是 zip, 这个 zip 更高阶, 并且可以由<code>Struct</code>的结构唯一确定.</li></ul><p>例如, 高阶形式的<code>Array</code>的 zip 可以这么实现:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zip</span>&lt;A, B, C&gt;<span class="params">(with f: @escaping <span class="params">(A, B)</span></span></span> -&gt; <span class="type">C</span>) -&gt; ([<span class="type">A</span>], [<span class="type">B</span>]) -&gt; [<span class="type">C</span>] &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; arrayA, arrayB <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">var</span> results: [<span class="type">C</span>] = []</span><br><span class="line">    <span class="keyword">let</span> maxCount = <span class="built_in">min</span>(arrayA.<span class="built_in">count</span>, arrayB.<span class="built_in">count</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;maxCount &#123;</span><br><span class="line">      results.append(f(arrayA[index], arrayB[index]))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多元-zip"><a class="markdownIt-Anchor" href="#多元-zip"></a> 多元 zip</h2><p>在二元 zip 的基础上, 把 f 的输入个数增加即可. 最常见的多元 zip 也是基于 tuple的, 即<code>f: (T1, T2, T3...) -&gt; (T1, T2, T3...)</code>.<br>当然参照二元的例子, 也有高阶的多元 zip.</p><h2 id="zip和map的联系"><a class="markdownIt-Anchor" href="#zip和map的联系"></a> <code>zip</code>和<code>map</code>的联系</h2><p><code>map</code>可以看成是通用的多元 zip 的一个特例. 固定 f 中的输入个数为1个即可得到 map 的定义.<br>给定一个映射<code>f: A -&gt; B</code>,  对任意一个包含<code>T</code>的结构<code>Struct&lt;T&gt;</code>, 我们一定可以给出映射<code>g: Struct&lt;A&gt; -&gt; Struct&lt;B&gt;</code>.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;ul class=&quot;markdownIt-TOC&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84-zip&quot;&gt;最常见的 zip&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#swift-%E6%8F%90%E4%BE%9B%E7%9A%84-zip&quot;&gt;Swift 提供的 zip&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%80%9A%E7%94%A8%E7%9A%84%E4%BA%8C%E5%85%83-zip&quot;&gt;通用的二元 zip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%A4%9A%E5%85%83-zip&quot;&gt;多元 zip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#zip%E5%92%8Cmap%E7%9A%84%E8%81%94%E7%B3%BB&quot;&gt;&lt;code&gt;zip&lt;/code&gt;和&lt;code&gt;map&lt;/code&gt;的联系&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;这里记录了 &lt;a href=&quot;http://pointfree.co&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pointfree.co&lt;/a&gt; 上, 以下三期视频的 notes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.pointfree.co/episodes/ep23-the-many-faces-of-zip-part-1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ep #23. The Many Faces of Zip: Part 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.pointfree.co/episodes/ep24-the-many-faces-of-zip-part-2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ep #24. The Many Faces of Zip: Part 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.pointfree.co/episodes/ep25-the-many-faces-of-zip-part-3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ep #25. The Many Faces of Zip: Part 3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;zip的本质: 一个映射&lt;/p&gt;
&lt;h2 id=&quot;最常见的-zip&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#最常见的-zip&quot;&gt;&lt;/a&gt; 最常见的 zip&lt;/h2&gt;
&lt;p&gt;考虑显然存在这样的映射&lt;code&gt;A, B -&amp;gt; (A, B)&lt;/code&gt;. 那么对任意一个包含&lt;code&gt;T&lt;/code&gt;的结构&lt;code&gt;Struct&amp;lt;T&amp;gt;&lt;/code&gt;, 我们一定可以给出映射&lt;code&gt;g: Struct&amp;lt;A&amp;gt; , Struct&amp;lt;B&amp;gt; -&amp;gt; Struct&amp;lt;(A, B)&amp;gt;&lt;/code&gt;. 这样的映射&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;g&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.625em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;就是&lt;code&gt;zip&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;这里的&lt;code&gt;Struct&lt;/code&gt;可以是 Swift 中的许多有意义的结构, 比如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Optional&lt;/li&gt;
&lt;li&gt;Array&lt;/li&gt;
&lt;li&gt;function&lt;/li&gt;
&lt;li&gt;callback function&lt;/li&gt;
&lt;li&gt;任意有&amp;quot;包含&amp;quot;关系的 plain structure&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如, 针对&lt;code&gt;Optional&lt;/code&gt;, 我们可以实现&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;zip&lt;/span&gt;&amp;lt;A, B&amp;gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; lhs: Optional&amp;lt;A&amp;gt;, &lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; rhs: Optional&amp;lt;B&amp;gt;)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Optional&lt;/span&gt;&amp;lt;(&lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;B&lt;/span&gt;)&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = lhs, &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; b = rhs &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; .some((a, b))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://crystdragon.github.io/categories/notes/"/>
    
    <category term="Swift" scheme="https://crystdragon.github.io/categories/swift/"/>
    
    
    <category term="pointfree.co" scheme="https://crystdragon.github.io/tags/pointfree-co/"/>
    
    <category term="Functional Programming" scheme="https://crystdragon.github.io/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>Swift Practices &amp; Perls (2)</title>
    <link href="https://crystdragon.github.io/2020/swift-practices-perls-2/"/>
    <id>https://crystdragon.github.io/2020/swift-practices-perls-2/</id>
    <published>2020-07-29T16:00:00.000Z</published>
    <updated>2020-07-30T12:35:17.094Z</updated>
    
    <content type="html"><![CDATA[<p><ul class="markdownIt-TOC"><li><a href="#%E6%A0%87%E5%87%86%E5%BA%93%E6%8B%BE%E9%81%97">标准库拾遗</a><ul><li><a href="#string%E5%92%8C%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><code>String</code>和其他类型之间的转换</a></li><li><a href="#comparisons">Comparisons</a></li><li><a href="#lazy-or-not">Lazy or not</a></li><li><a href="#compiler-synthesized-conformance">Compiler-synthesized conformance</a><ul><li><a href="#%E4%BE%9D%E8%B5%96-compiler-synthesized-%E4%BB%A3%E7%A0%81%E7%9A%84%E9%80%BB%E8%BE%91%E6%B3%A8%E5%85%A5%E6%8A%80%E5%B7%A7">依赖 compiler-synthesized 代码的逻辑注入技巧</a></li></ul></li></ul></li><li><a href="#tricks-patterns">Tricks &amp; Patterns</a><ul><li><a href="#implementing-ghost-operator">Implementing “ghost operator”</a><ul><li><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF">问题背景</a></li><li><a href="#%E9%97%AE%E9%A2%98%E7%9B%AE%E6%A0%87">问题目标</a></li><li><a href="#%E5%AE%9E%E7%8E%B0">实现</a></li></ul></li></ul></li></ul></p><hr><p>下文部分内容成于2018年</p><hr><p>本文继续上一篇<a href="/2020/swift-practices-perls-1/">Swift Practices &amp; Perls (1)</a>, 记录标准库学习过程中的技巧.</p><h2 id="标准库拾遗"><a class="markdownIt-Anchor" href="#标准库拾遗"></a> 标准库拾遗</h2><p>Swift 标准库提供的 API 强大而优雅. 这里归纳总结了一些网上不常见的点.</p><h3 id="string和其他类型之间的转换"><a class="markdownIt-Anchor" href="#string和其他类型之间的转换"></a> <code>String</code>和其他类型之间的转换</h3><p>一方面, 标准库中存在多个 protocol, 来关联自定义类型和<code>String</code>. 通常, 在需要按文本格式打印某个对象, 或涉及到用文本进行序列化/反序列化时, 可能会使用到这些 protocol.</p><ul><li><code>ExpressibleByStringLiteral</code> (旧名<code>StringLiteralConvertible</code>). 遵循该 protocol 的类型, 支持使用 string literal 初始化.</li><li><code>CustomStringConvertible</code>和<code>CustomDebugStringConvertible</code>. 支持最基本的输出到一个<code>String</code>.</li><li><code>LosslessStringConvertible</code>. 该 protocol 继承自 <code>CustomStringConvertible</code>. 与后者不同的是, 该 protocol 的遵循者必须提供和<code>String</code>之间双向的精确转化. 因此某种意义上说, 遵循本 protocol 的类型转化成的<code>String</code>可用范围更广, 不限于 debug/print. 因为不用担心2个不同的对象对应到同一个<code>String</code>.</li><li><code>TextOutputStreamable</code>. 支持按流式增量添加到已有的 stream 的末尾. 因为支持增量添加, 所以遵循者实际实现时, 可能和其他输出<code>String</code>的 protocol 相比, 内存占用上可以有一些优化.</li></ul><p>另一方面, <code>String</code>本身也存在好几种 initializer. 标准库建议我们使用<code>String</code>的各种初始化方法, 而不要直接调用上面各个 protocol 定义的方法.</p><ul><li><code>init&lt;T&gt;(_ value: T, radix: Int = default, uppercase: Bool = default)</code>. 把<code>Int</code>按某个进制转换成<code>String</code>.</li><li><code>init&lt;T&gt;(_ value: T) where T : LosslessStringConvertible</code>.</li><li><code>init&lt;Subject&gt;(describing: Subject)</code>. 优先使用<code>TextOutputStreamable</code>的实现, 最后使用<code>CustomDebugStringConvertible</code>的实现, 偏向精准性.</li><li><code>init&lt;Subject&gt;(reflecting: Subject)</code>. 优先使用<code>CustomDebugStringConvertible</code>, 最后使用<code>TextOutputStreamable</code>, 偏向debug.</li></ul><h3 id="comparisons"><a class="markdownIt-Anchor" href="#comparisons"></a> Comparisons</h3><p>在STL中, 并非所有可比的对象都直接遵循<code>Comparable</code>, 但一定要求最终的底层 element 对象是遵循的.<br>对于不直接遵循<code>Comparable</code>的类型来说, 他们比较各自对象的方式无外乎通过 operator 或 method.</p><a id="more"></a><ul><li><code>StringProtocol</code>遵循者中, <code>String</code>直接遵循<code>Comparable</code>; 但<code>SubString</code>没有, 可通过 <code>&lt;</code>运算符比较.</li><li>遵循<code>Sequence</code>的类型, 如果本身不遵循<code>Comparable</code>, 但<code>Element</code>实际遵循<code>Comparable</code>, 那么可以通过<code>lexicographicallyPrecedes</code>进行字典比较.</li><li>在<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0283-tuples-are-equatable-comparable-hashable.md" target="_blank" rel="noopener">SE-0283</a>被合入 Swift 前(不早于Swift 5.3), 由多个分量组成的 tuple, 本身是不遵循<code>Comparable</code>的. 但是标准库为含有2-6个分量的 tuple, 手动重载了<code>&lt;</code>操作符, 允许我们直接使用<code>&lt;</code>进行字典比较.</li></ul><h3 id="lazy-or-not"><a class="markdownIt-Anchor" href="#lazy-or-not"></a> Lazy or not</h3><p>当我们要给一个<code>Sequence</code>/<code>Collection</code>增加一个方法的时候, 要考虑是否要把这个方法设计成 lazy 的. 这里的 lazy 指的是, 当方法执行时, 不实际开辟内存创建一个新的集合, 或实际遍历整个序列, 而是把相关待执行的操作/规则先保留, 等到后面不得不执行的时候再执行.</p><p>当这个方法返回一个新的<code>Sequence</code>/<code>Collection</code>时, 这里要考虑的 lazy 的含义还是两重的. 一方面要考虑当前方法是否 lazy, 另一方面要考虑对返回的集合进一步执行非 lazy 方法时, 是否 lazy.</p><p>标准库给这个问题作出了很好的示范.<br>有一些方法本身一定是 lazy 的, 返回的新对象的后续操作是否 lazy 要看其他条件. 例如:</p><ul><li><code>BidirectionalCollection.reversed()</code>. 方法本身在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>内即完成.</li><li><code>Sequence.enumerated()</code>. 方法本身在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>内即完成.</li><li><code>Sequence.lazy</code>. 方法本身在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>内即完成. 并且返回一个遵循了<code>LazySequenceProtocol</code>的对象. 从而保证后续任意操作均为 lazy.<br>另一些方法, 本身是否 lazy 要看<code>Self</code>, 在一般情况下是 imperative 的, 但当<code>Self: LazySequenceProtocol</code>时, 是 lazy 的. 例如:</li><li><code>Sequence.map()</code></li><li><code>Sequence.filter()</code></li></ul><p>这里有一个关键的 protocol <code>LazySequenceProtocol</code>. 这个 protocol 在体系中起到语义标记作用, 一个遵循了<code>Sequence</code>的类型是否进一步遵循<code>LazySequenceProtocol</code>, 会导致在该类型上调用方法时, 产生不同的结果.</p><p>现在可以回答一开始的问题. 我们自己写的方法, 如果操作是有消耗性的, 或者耗时很长, 可以考虑把他定义成 lazy 的. 实现时也要遵循下面这个约定:</p><ul><li>在默认情况下, 返回一个以<code>Self</code>作为模板参数的泛型结构. 这个结构只是一个 wrapper, 给<code>Self</code>作了一层浅的封装, 这个方法本身就是 lazy 即可.</li><li>在<code>Self: LazySequenceProtocol</code>时, 返回一个遵循了<code>LazySequenceProtocol</code>的 wrapper, 保证后续操作可以继续用 lazy 操作串起来.</li><li>在 Swift 支持 conditional conformance 后, 上述两点可以很方便地用同一个 wrapper 类型统一起来.</li></ul><p>需要注意的是, 正如标准库开发者在 Swift Forums 上指出过: 对一个方法, 并不应该不加思考地就决定把他设置成 lazy 的. 因为 lazy 只是把当前的遍历行为延迟到后面. 如果后面反复执行时, 反而可能触发多次遍历, 还不如把这个遍历当前就消耗掉.<br>例如: 如果对于<code>filter()</code>方法, 我们无条件的返回一个 lazy 的 wrapper. 那么会产生令人惊讶的后果:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad case</span></span><br><span class="line"><span class="keyword">let</span> range = <span class="number">1</span>..&lt;<span class="number">10000</span></span><br><span class="line"><span class="keyword">let</span> array = range.myFilter(&#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125;)  <span class="comment">// 假如这个 myFilter 在 O(1) 里返回一个 wrapper</span></span><br><span class="line"><span class="built_in">print</span>(array.<span class="built_in">count</span>)  <span class="comment">// 触发一次 1..&lt;10000 的遍历</span></span><br><span class="line"><span class="built_in">print</span>(array.<span class="built_in">count</span>)  <span class="comment">// 又触发一次 1..&lt;10000 的遍历</span></span><br></pre></td></tr></table></figure><p>这显然是我们不想看到的. 对这样的方法, 我们应该默认把他按 imperative 的方式实现.<br>而只在<code>Self:LazySequenceProtocol</code>的情形下, 才进行lazy的行为. 注意到这个情况下, 因为调用链上游某处显式出现了一次<code>.lazy</code>, 所以这个责任已经转嫁到调用者, 调用者应该十分清楚 code 的行为, 并不会产生 surprise.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good case</span></span><br><span class="line"><span class="keyword">let</span> range = <span class="number">1</span>..&lt;<span class="number">10000</span></span><br><span class="line"><span class="keyword">let</span> array = range.<span class="built_in">lazy</span>.<span class="built_in">filter</span>(&#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125;) </span><br><span class="line"><span class="built_in">print</span>(array.<span class="built_in">count</span>)  <span class="comment">// 触发一次 1..&lt;10000 的遍历</span></span><br><span class="line"><span class="built_in">print</span>(array.<span class="built_in">count</span>)  <span class="comment">// 又触发一次 1..&lt;10000 的遍历</span></span><br></pre></td></tr></table></figure><h3 id="compiler-synthesized-conformance"><a class="markdownIt-Anchor" href="#compiler-synthesized-conformance"></a> Compiler-synthesized conformance</h3><p>给我们的自定义类, 在某些情况下直接添加 protocol conformance, 不提供具体实现, compiler 会生成默认的实现. 涉及到的 protocol 有:</p><ul><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0166-swift-archival-serialization.md#detailed-design" target="_blank" rel="noopener">Codable</a></li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0185-synthesize-equatable-hashable.md" target="_blank" rel="noopener">Equatable</a></li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0206-hashable-enhancements.md#source-compatibility" target="_blank" rel="noopener">Hashable</a></li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0266-synthesized-comparable-for-enumerations.md" target="_blank" rel="noopener">Comparable</a></li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0194-derived-collection-of-enum-cases.md" target="_blank" rel="noopener">CaseIterable</a></li></ul><p>各个 protocol 支持自动遵循的自定义类型有不一样的要求:</p><ul><li><code>Comparable</code>和<code>CaseIterable</code>只作用于 enum.</li><li><code>Equatable</code>和<code>Hashable</code>只作用于 enum 和 struct.</li><li><code>Codable</code>只作用于 struct 和 class.</li></ul><p>这些自定义遵循都有一些共同的特点/要求:</p><ul><li>要求类型的成员, 按树形结构递归满足遵循条件. 例如:<ul><li>遵循<code>Codable</code>类型的各个属性的类型本身要遵循<code>Codable</code>.</li><li>遵循<code>Comparable</code>类型的 enum, 如果某个 case 携带了 associated value, 那么该 value 的类型也要遵循<code>Comparable</code>.</li></ul></li><li>在以前: 必须是定义类型时立即 conform 某个 protocol 才可以触发编译器自动合成代码, 在 extension 中 conform 是无效的. 现在, 允许在和自定义类型的定义同一个 source file 下的 extension 中进行 conform. 这也是为了和 conditional conformance 进行配合.</li><li>这里列出的各个 protocol 的命名规则是统一的: “xxx+able”, “a&quot;前没有&quot;e”. 但须注意, 这个规则只是针对上面列出的几个protocol, STL 里当然也存在按&quot;+e+able&quot;命名的 protocol (比如<code>Strideable</code>, 目前还没有改动命名).</li></ul><h4 id="依赖-compiler-synthesized-代码的逻辑注入技巧"><a class="markdownIt-Anchor" href="#依赖-compiler-synthesized-代码的逻辑注入技巧"></a> 依赖 compiler-synthesized 代码的逻辑注入技巧</h4><p>需要明确, 这几个 protocol 开发者一行代码不写就 work 的背后原理, 并不是命中了一个 default 实现的的 protocol extension implementation, 而是由编译器实打实地合成了实现代码. 编译器合成的实现和我们手动输入的代码有相同地位, 也会参与重载决议等等编译阶段. 因此, 我们可以利用这一点, 给这个看似被编译器定死, 而无法扩展的功能, 注入一些自定义逻辑.</p><p>例如: <code>Codable</code>默认需要遵循者实现<code>func hash(into hasher: inout Hasher)</code>, 我们实现时需要不停调用<code>Hasher.combine()</code>. 如果这个实现由编译器代替我们完成, 编译器实际上也是做了相同的工作. 而编译器每次调用<code>Hasher.combine()</code>实际上和我们手动编写时的调用完全无异, 每一次调用都会参与重载决议. 因此, 虽然<code>Hasher</code>是标准库提供的类, 但我们如果给<code>Hasher</code>增加几个重载方法, 并在我们自己的 module 中设法使这几个重载方法被命中, 那就相当于绕过了标准库的实现.</p><p>下面的代码, 展示了这样一个功能: 我们想看看, 我们的 module 中所有<code>Optional&lt;Int&gt;</code>被 hash 的次数.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Model</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a: <span class="type">Int?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Hasher</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 给标准库类型增加的 extension, 这个方法比 Hasher 已有的2个方法更加限定, 因此命中时优先级更高</span></span><br><span class="line">  <span class="comment">// 实际上, 编译器给 Model 生成的 Hashable 实现代码里, 就会命中这个 combine, 而非 Hasher 自带的 combine</span></span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(<span class="number">_</span> value: Int?)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"we are hashing an optional int here!!!"</span>)</span><br><span class="line">    combine(<span class="type">AnyHashable</span>(value))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用2个 Model 类型的 key, 创建 Dictionary</span></span><br><span class="line"><span class="keyword">let</span> dict = [</span><br><span class="line">  <span class="type">Model</span>(a: <span class="number">3</span>): <span class="number">3</span>,</span><br><span class="line">  <span class="type">Model</span>(a: <span class="number">4</span>): <span class="number">4</span></span><br><span class="line">]</span><br><span class="line"><span class="comment">// console output:</span></span><br><span class="line"><span class="comment">// we are hashing an optional int here!!!</span></span><br><span class="line"><span class="comment">// we are hashing an optional int here!!!</span></span><br></pre></td></tr></table></figure><p>当然这里的例子比较简单, 对于比较复杂的编译器支持生成实现代码的 protocol, 例如<code>Encodable/Decodable</code>, 可以有更花式的做法. 例如<a href="http://davelyon.net/2017/08/16/jsondecoder-in-the-real-world" target="_blank" rel="noopener">这边的例子</a>, 就是通过增加优先级高的重载方法, 来增强现有<code>Codable</code>的自定义能力.</p><h2 id="tricks-patterns"><a class="markdownIt-Anchor" href="#tricks-patterns"></a> Tricks &amp; Patterns</h2><h3 id="implementing-ghost-operator"><a class="markdownIt-Anchor" href="#implementing-ghost-operator"></a> Implementing “ghost operator”</h3><h4 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h4><p>在 Swift Standard Library 中某些 Collection 实现了一种 subscript, 接受的实参是<code>...</code>, 生成一个涵盖整个 collection 范围的<code>SubSequence</code>.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment">// sub 的类型是 ArraySlice</span></span><br><span class="line"><span class="keyword">let</span> sub = array[...]</span><br></pre></td></tr></table></figure><p>当然<code>...</code>在现有的 Swift 标识符规则下, 只能是一个 operator, 不可能是一个常量/变量. 因此显然这个 subscript 的入参类型是一个 function type.</p><h4 id="问题目标"><a class="markdownIt-Anchor" href="#问题目标"></a> 问题目标</h4><p>我们考虑更一般的情况, 假设我们想要实现这样一个 subscript.</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Special</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 类型暂时不确定的一个subscript</span></span><br><span class="line">  <span class="keyword">subscript</span>(<span class="comment">/*SpecialOpearator*/</span>) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"SpecialOpearator called"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想要能被如此使用</span></span><br><span class="line"><span class="type">Special</span>()[...]</span><br></pre></td></tr></table></figure><p>为了能方便的使用, 我们的实现需要保证以下几点:</p><ul><li><code>[...]</code>这个 subscript 调用可以完美解析, 不会出现找不到 subscript 方法, 或者出现二义性.</li><li>在实现过程中, 暴露出来的无关接口越少越好.</li><li>这个 operator 只能是用在我们这个 subscript 中, 任何其他方式都不能被调用, 如果用户用<code>...</code>时都意识不到这是一个自定义的 operator, 似乎只是一个 magical special identifier, 那就更好不过了.</li></ul><h4 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h4><p>(1) 使用 case-less enum 建立一个局部作用域, 并添加一个无实现的 operator 方法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">_ThreeDot</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">postfix</span> <span class="function"><span class="keyword">func</span> ... <span class="params">(rhs: _ThreeDot)</span></span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) 使用上述 operator 方法的签名作为入参类型, 定义我们想要的 subscript</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">ThreeDot</span> = (_ThreeDot) -&gt; <span class="type">Void</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Special</span> </span>&#123;</span><br><span class="line">  <span class="keyword">subscript</span>(<span class="number">_</span> op: <span class="type">ThreeDot</span>) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"SpecialOpearator called"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就可以按想要的方式调用<code>Special()[...]</code>.</p><p>实现过程中的要点主要有:</p><ul><li>我们按标准的 Swift custom operator 的定义方法, 将方法定义在一个宿主 enum 里, 并且使这个方法接受一个宿主类型的参数, 可以有效避免<code>...</code> operator 和相同作用域内其他同名 operator 的冲突.</li><li>我们定义的 enum, 是 non-inhabitant type, 只起到命名空间的作用. 并且由于在代码中的任何地方都不可能建立一个这个 enum 类型的实例. 所以<code>...</code>永远不可能被真正调用到: 调用需要的实参永远不可能被实例化出来嘛. 这个 operator 只能&quot;相当&quot;于一个 identifier 被引用, 而不会被调用.</li></ul><p>可以看到, 这个技巧不限于 Swift 已经定义的<code>...</code>, 可以用在任何其他名字的自定义 operator; 引用地点也不一定非得是 subscript, 任何 function/method 中都是可以的.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;ul class=&quot;markdownIt-TOC&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%A0%87%E5%87%86%E5%BA%93%E6%8B%BE%E9%81%97&quot;&gt;标准库拾遗&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#string%E5%92%8C%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2&quot;&gt;&lt;code&gt;String&lt;/code&gt;和其他类型之间的转换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#comparisons&quot;&gt;Comparisons&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#lazy-or-not&quot;&gt;Lazy or not&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#compiler-synthesized-conformance&quot;&gt;Compiler-synthesized conformance&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BE%9D%E8%B5%96-compiler-synthesized-%E4%BB%A3%E7%A0%81%E7%9A%84%E9%80%BB%E8%BE%91%E6%B3%A8%E5%85%A5%E6%8A%80%E5%B7%A7&quot;&gt;依赖 compiler-synthesized 代码的逻辑注入技巧&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tricks-patterns&quot;&gt;Tricks &amp;amp; Patterns&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#implementing-ghost-operator&quot;&gt;Implementing “ghost operator”&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF&quot;&gt;问题背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%97%AE%E9%A2%98%E7%9B%AE%E6%A0%87&quot;&gt;问题目标&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%9E%E7%8E%B0&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下文部分内容成于2018年&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文继续上一篇&lt;a href=&quot;/2020/swift-practices-perls-1/&quot;&gt;Swift Practices &amp;amp; Perls (1)&lt;/a&gt;, 记录标准库学习过程中的技巧.&lt;/p&gt;
&lt;h2 id=&quot;标准库拾遗&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#标准库拾遗&quot;&gt;&lt;/a&gt; 标准库拾遗&lt;/h2&gt;
&lt;p&gt;Swift 标准库提供的 API 强大而优雅. 这里归纳总结了一些网上不常见的点.&lt;/p&gt;
&lt;h3 id=&quot;string和其他类型之间的转换&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#string和其他类型之间的转换&quot;&gt;&lt;/a&gt; &lt;code&gt;String&lt;/code&gt;和其他类型之间的转换&lt;/h3&gt;
&lt;p&gt;一方面, 标准库中存在多个 protocol, 来关联自定义类型和&lt;code&gt;String&lt;/code&gt;. 通常, 在需要按文本格式打印某个对象, 或涉及到用文本进行序列化/反序列化时, 可能会使用到这些 protocol.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ExpressibleByStringLiteral&lt;/code&gt; (旧名&lt;code&gt;StringLiteralConvertible&lt;/code&gt;). 遵循该 protocol 的类型, 支持使用 string literal 初始化.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CustomStringConvertible&lt;/code&gt;和&lt;code&gt;CustomDebugStringConvertible&lt;/code&gt;. 支持最基本的输出到一个&lt;code&gt;String&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LosslessStringConvertible&lt;/code&gt;. 该 protocol 继承自 &lt;code&gt;CustomStringConvertible&lt;/code&gt;. 与后者不同的是, 该 protocol 的遵循者必须提供和&lt;code&gt;String&lt;/code&gt;之间双向的精确转化. 因此某种意义上说, 遵循本 protocol 的类型转化成的&lt;code&gt;String&lt;/code&gt;可用范围更广, 不限于 debug/print. 因为不用担心2个不同的对象对应到同一个&lt;code&gt;String&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TextOutputStreamable&lt;/code&gt;. 支持按流式增量添加到已有的 stream 的末尾. 因为支持增量添加, 所以遵循者实际实现时, 可能和其他输出&lt;code&gt;String&lt;/code&gt;的 protocol 相比, 内存占用上可以有一些优化.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另一方面, &lt;code&gt;String&lt;/code&gt;本身也存在好几种 initializer. 标准库建议我们使用&lt;code&gt;String&lt;/code&gt;的各种初始化方法, 而不要直接调用上面各个 protocol 定义的方法.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;init&amp;lt;T&amp;gt;(_ value: T, radix: Int = default, uppercase: Bool = default)&lt;/code&gt;. 把&lt;code&gt;Int&lt;/code&gt;按某个进制转换成&lt;code&gt;String&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;init&amp;lt;T&amp;gt;(_ value: T) where T : LosslessStringConvertible&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;init&amp;lt;Subject&amp;gt;(describing: Subject)&lt;/code&gt;. 优先使用&lt;code&gt;TextOutputStreamable&lt;/code&gt;的实现, 最后使用&lt;code&gt;CustomDebugStringConvertible&lt;/code&gt;的实现, 偏向精准性.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;init&amp;lt;Subject&amp;gt;(reflecting: Subject)&lt;/code&gt;. 优先使用&lt;code&gt;CustomDebugStringConvertible&lt;/code&gt;, 最后使用&lt;code&gt;TextOutputStreamable&lt;/code&gt;, 偏向debug.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;comparisons&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#comparisons&quot;&gt;&lt;/a&gt; Comparisons&lt;/h3&gt;
&lt;p&gt;在STL中, 并非所有可比的对象都直接遵循&lt;code&gt;Comparable&lt;/code&gt;, 但一定要求最终的底层 element 对象是遵循的.&lt;br&gt;
对于不直接遵循&lt;code&gt;Comparable&lt;/code&gt;的类型来说, 他们比较各自对象的方式无外乎通过 operator 或 method.&lt;/p&gt;</summary>
    
    
    
    <category term="Swift" scheme="https://crystdragon.github.io/categories/swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Image Orientation</title>
    <link href="https://crystdragon.github.io/2020/Image-Orientation/"/>
    <id>https://crystdragon.github.io/2020/Image-Orientation/</id>
    <published>2020-07-27T16:00:00.000Z</published>
    <updated>2020-07-30T17:05:03.535Z</updated>
    
    <content type="html"><![CDATA[<p><ul class="markdownIt-TOC"><li><a href="#%E8%83%8C%E6%99%AF">背景</a><ul><li><a href="#%E4%BC%A0%E7%BB%9F%E7%9B%B8%E6%9C%BA">传统相机</a></li><li><a href="#dslr">DSLR</a></li></ul></li><li><a href="#%E5%AF%B9%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%BD%B1%E5%93%8D">对图像算法的影响</a></li><li><a href="#orientation-tag-%E7%9A%84%E8%A1%A8%E7%A4%BA">Orientation tag 的表示</a><ul><li><a href="#raw-exif-%E4%BF%A1%E6%81%AF">Raw exif 信息</a><ul><li><a href="#apple-api">Apple API</a></li></ul></li><li><a href="#uiimage%E7%9B%B8%E5%85%B3-api"><code>UIImage</code>相关 API</a></li></ul></li><li><a href="#%E4%BD%BF%E7%94%A8-uikit-%E8%8E%B7%E5%8F%96uiimage%E6%97%B6-%E7%B3%BB%E7%BB%9F%E5%AF%B9imageorientation%E7%9A%84%E5%A1%AB%E5%85%85%E6%96%B9%E5%BC%8F">使用 UIKit 获取<code>UIImage</code>时, 系统对<code>imageOrientation</code>的填充方式</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E7%9B%B8%E5%AF%B9%E5%85%B3%E7%B3%BB">基本相对关系</a></li><li><a href="#%E5%90%8E%E7%BD%AE%E6%91%84%E5%83%8F%E5%A4%B4">后置摄像头</a></li><li><a href="#%E5%89%8D%E7%BD%AE%E6%91%84%E5%83%8F%E5%A4%B4">前置摄像头</a></li></ul></li><li><a href="#case-face-detection-%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2">Case: Face Detection 中的坐标变换</a></li></ul></p><hr><p>原文成于2018年12月</p><hr><h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>为什么存在 Image Orientation</p><h3 id="传统相机"><a class="markdownIt-Anchor" href="#传统相机"></a> 传统相机</h3><ul><li>传统相机横向拍摄, 胶卷和照片也按横向方位固定尺寸.</li><li>拍竖直方向的景的时候, 摄影师把相机旋转90度, 拍到的原始照片是横向的.</li><li>要正确还原现场的情况, 需要手动把照片旋转90度.</li></ul><h3 id="dslr"><a class="markdownIt-Anchor" href="#dslr"></a> DSLR</h3><ul><li>用户的持相机方式和需求没有本质变化.</li><li>仍然需要外部额外信息来帮助确定怎么旋转拍得的图像.<ul><li>用户使用相机上的 UI, 手动输入旋转信息.</li><li>根据硬件的重力加速计自动确定方向.</li></ul></li><li>基于性能和效率原因, 并不会把 raw data 进行旋转生成一张新图片, 而是加上一个 tag, 这个 tag 就表示 image orientation.</li><li>各端显示这样的图片时, 需要读取这个 tag, 并在渲染时给 raw data 加上一个 transform.</li></ul><h2 id="对图像算法的影响"><a class="markdownIt-Anchor" href="#对图像算法的影响"></a> 对图像算法的影响</h2><p>当对某个图像执行某些算法时, 除了必要的图像 data 信息, 还可能需要已知的 orientation 信息. 例如很多人脸检测算法, 在有先验的 orientation 知识时, 通常能有更好的效果. 例如, Apple 的 CoreImage 支持人脸检测, <a href="https://developer.apple.com/documentation/coreimage/cidetectorimageorientation" target="_blank" rel="noopener">其 API 接受 orientation 参数</a>.</p><a id="more"></a><p>但需要注意, 这个 orientation 本质上就是一个 Int 值. 但某个 orientation 值对应的标识符名称, 在不同的 API 下, 可能对应不同的含义. 通常有两种可能性:</p><ul><li>把 raw data 变换成自然方位的图像时, 应该进行的旋转</li><li>自然的图像在保存成 raw data 时, 执行的旋转; 或者说成 raw data 相对于自然方位所进行的旋转</li></ul><p>在我个人接触到的大部分 API 中, 这里的 orientation, 一般表示前者.</p><h2 id="orientation-tag-的表示"><a class="markdownIt-Anchor" href="#orientation-tag-的表示"></a> Orientation tag 的表示</h2><h3 id="raw-exif-信息"><a class="markdownIt-Anchor" href="#raw-exif-信息"></a> Raw exif 信息</h3><p>任意来自第三方相机或手机拍摄的图像文件, <a href="http://jpegclub.org/exif_orientation.html" target="_blank" rel="noopener">orientation 存储在 exif 信息中</a>. 共有8个可能的取值.</p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">0th Row</th><th style="text-align:left">0th Column</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">top</td><td style="text-align:left">left</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">top</td><td style="text-align:left">right</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">bottom</td><td style="text-align:left">right</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">bottom</td><td style="text-align:left">left</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">left</td><td style="text-align:left">top</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">right</td><td style="text-align:left">top</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">right</td><td style="text-align:left">bottom</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">left</td><td style="text-align:left">bottom</td></tr></tbody></table><p>下图表述的是: 假设拍摄对象自然成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span> 图像时, 每一种 orientation 下, 存储在 raw data 中的图像姿态.</p><p><img src="/2020/Image-Orientation/exif_orientation.png" alt="exif orientation"></p><p>对表中的每一行有两种等价的解释:</p><ul><li>raw data中, 0th row, 0th column, 对应合理的真实场景中的哪条边.</li><li>把 raw data 通过 transform 还原后,  0th row, 0th column 被变换到哪个位置.</li></ul><p>例如: 当 orientation 是5时, 可以发现, raw data 中第0行的 data, 对应 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span> 左边的一竖, 即应该变换到 left; raw data 中第0列的 data, 对应 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span> 顶上的一行, 即应该变换到 top.</p><h4 id="apple-api"><a class="markdownIt-Anchor" href="#apple-api"></a> Apple API</h4><ul><li>在 Apple 平台上, 使用 ImageIO 这个 framework, 通过<code>URL</code>/file data 直接读取, 可以在<code>kCGImagePropertyOrientation</code>这个 property key 的位置直接读取到 tag.</li><li>这个值可以直接输入许多算法, 例如上述 face detection filter.</li></ul><h3 id="uiimage相关-api"><a class="markdownIt-Anchor" href="#uiimage相关-api"></a> <code>UIImage</code>相关 API</h3><ul><li><code>UIImage</code>是<code>NSImage</code>的简化版, 本身不包含任何 meta data, 当然没有 exif 信息.<ul><li><code>UIImage</code>除了包含 raw data 外, 通过一个额外的<code>imageOrientation</code>属性来保存等价的 orientation 信息.</li><li>从<code>UIImagePickerController</code>生成<code>UIImage</code>时, framework 已经填充好<code>imageOrientation</code>.</li><li>通过 AVFoundation 的<code>AVCaptureOutput</code>返回 data 时, 返回的 pixel buffer 没有任何 orientation 的信息. 需要手动组装:<ul><li>可以通过当前系统的硬件情况.</li><li>或者读取由 output 随 buffer 返回的 <code>metadata</code>.</li><li>或者通过<code>captureConnection</code>的<code>videoOrientation</code>来 map 到一个<code>imageOrientation</code>.</li><li><code>isVideoMirrored</code>是否会影响获取到的值, <em>需要额外验证下</em>.</li></ul></li></ul></li><li><code>UIImage.Orientation</code>的定义: 一个enum, 每个 case 的名称其实非常好理解, 他表示的就是 raw data <em>应该</em>如何旋转/transform 来还原到真实的自然场景. 遇到标识符带<code>Mirrored</code>的, 意思是把 raw data 先按当前未旋转时的 y 轴左右镜像, 再旋转 (或者先旋转, 再按转完后的 local y 轴进行 mirror. 两者是一个意思)<ul><li>例如, <code>UIImage.Orientation.right</code>表示的就是: 把 raw data 朝右转90度(顺时针90度), 就可以还原到自然状态.</li><li>又如, <code>UIImage.Orientation.rightMirrored</code>表示的就是, 先把 raw data 左右翻转, 再朝右转90度, 就可以还原到自然状态.</li></ul></li><li><code>UIImage.Orientation</code>的使用<ul><li><code>UIImage</code>的<code>cgImage</code>和<code>UIImagePNGRepresentation</code>生成的 data, 都完全不包含 orientation, 因此遇到<code>UIImage</code>直接进行操作/存储时, 就等于只是用/保存了 raw data, 而非矫正过朝向的图片.</li><li><code>UIImage</code>的各个<code>draw</code>方法, 已经自动考虑其<code>imageOrientation</code>.</li><li>手动操纵<code>cgImage</code>的 data 绘制时<ul><li>涉及到<code>CGContext</code>绘制的场合, 需要使用<code>imageOrientation</code>对 context 进行 transform 再进行绘制, 或先生成一张已矫正过的临时 image.</li><li>如果需要传入给需要 exif orientation tag 的算法, 则应当把<code>imageOrientation</code>转成 exif 的 tag.</li><li><code>imageOrientation</code>和<code>kCGImagePropertyOrientation</code>的转化对应关系, 可以根据 exif specification 手动转换 rawValue, 也可以用 Apple 定义的 enum 直接进行同名 case 的映射 (例如<code>Image.Orientation.right</code>对应<code>CGImagePropertyOrientation.right</code>), 两者其实是一回事.</li></ul></li></ul></li></ul><p>需要注意的是, iOS 有些时候, 例如把带 exif orientation tag 的<code>CGImageDestination</code>存储到某个 file path 时, 似乎会把对应的 orientation 信息消耗掉, 最终存储的是已经旋转过的图片. 之所以这么做, 我想应该是系统为将来操作进行的一种简化. 再读取该文件时, 会发现没有对应的 orientation 信息了. 而另一些时候会把 exif 存储下来, 例如使用<code>UIImageJPEGRepresentation</code>的时候.<br>总之对于我们来说, 只需要依赖 API 就好, 不要自己去 cache orientation 的信息.</p><h2 id="使用-uikit-获取uiimage时-系统对imageorientation的填充方式"><a class="markdownIt-Anchor" href="#使用-uikit-获取uiimage时-系统对imageorientation的填充方式"></a> 使用 UIKit 获取<code>UIImage</code>时, 系统对<code>imageOrientation</code>的填充方式</h2><p>虽然对我们来说, <code>UIImagePickerController</code>返回的<code>UIImage</code>如何填充<code>imageOrientation</code>, 很多时候是一个透明的操作: 我们只需要取出<code>imageOrientation</code>, 对该值分情况进行操作就好. 但如果能进一步了解 iOS 填充<code>imageOrientation</code>的规则, 就可以在很多地方避免常识性错误. 一个最简单的例子就是, 用手机竖着拍人的时候, 返回的<code>imageOrientaion</code>不是<code>.up</code>.</p><h3 id="基本相对关系"><a class="markdownIt-Anchor" href="#基本相对关系"></a> 基本相对关系</h3><p>当我们把相机朝向前方, <em>逆时针</em>转90度时, 其实从相机的 local 视点来看, 世界是朝<em>顺时针</em>方向转了90度. 如果我们要把此时拍到的图片还原到现实世界的方位, 我们应该<em>逆时针</em>旋转拍得的照片.</p><h3 id="后置摄像头"><a class="markdownIt-Anchor" href="#后置摄像头"></a> 后置摄像头</h3><ul><li>后置相机在出厂时, 其安装正向方位对应 device 的<code>UIDeviceOrientation.landscapeLeft</code>(此时手机屏幕面向用户, home button 在右). 在这个方位下使用 UIKit 拍摄的<code>UIImage</code>, <code>imageOrientation</code>为<code>.up</code>. 之所以设定这个 device 方向为标准正方位, 我想应该是为了沿袭历史.</li><li>手机方位为为<code>.portrait</code>时, 相当于把手机从正方位顺时针旋转了90度, 按上述基本相对关系, UIKit 为生成的 image 填充的 orientation 为<code>.right</code></li><li>剩下2个除<code>.faceUp</code>和<code>.faceDown</code>的方位同理</li></ul><h3 id="前置摄像头"><a class="markdownIt-Anchor" href="#前置摄像头"></a> 前置摄像头</h3><p>前置摄像头有一个mirror的概念, 因为在屏幕朝向拍摄者的情况下, 如果把前置摄像头实际拍摄到的景象直接展示到屏幕上, 会发现实际中物体运动的方向和屏幕上物体运动的方向不一致, 容易使人产生误解.<br>因此一般情况下, 我们开发的软件会选择把拍到的图片<em>在旋转矫正完的基础上</em>作一次左右 mirror. (注意这里要先旋转, 再左右 mirror)</p><hr><p>实际上, <code>UIImagePickerController</code>在拍摄实时预览时使用的是 mirror 后的图, 但最终输出(也就是按下拍摄按钮后弹出的确认预览时的图)的是未 mirror 的图, 两者不是统一的.</p><hr><p>我们先看未 mirror 的情况</p><ul><li>前置相机和后置相机的安装方位相反, 对应 device 方位为<code>.landscapeRight</code>时, 为相机初始的正向安装方位, 此时生成的 image 未 mirror 情况下为: <code>.up</code>.</li><li>手机方位为<code>.portrait</code>时, <em>在摄像头视角下</em> (不是在人眼的面朝屏幕的视角下), 相当于把相机<em>顺时针</em>旋转90度, 按上述分析, UIKit 生成的 image 朝向为<code>.right</code>.</li></ul><hr><p>也就是说, 无论是前置还是后置摄像头, 在没有 mirror 的情况下, 只要手机是<code>.portrait</code>, UIKit 生成的 image 朝向一律为<code>.right</code>.</p><hr><p>如果需要 mirror, 只能是我们开发者把图像进行调整. 最快速的方法就是直接修改拿到的图像的<code>imageOrientation</code>. 但需要注意的是, 不能简单地在原来的 case 名字后加上&quot;Mirrored&quot;字样来解决. 这正是前文所说的, 因为&quot;~Mirrored&quot;表示的是把图像在<em>旋转前</em>先左右 mirror (或者等价地说, 要在旋转后的图上按新的旋转过的对称轴 mirror), 而我们预期的行为是先旋转, 最后再左右 mirror. 当左右翻转和某个特定的旋转操作结合时, mirror 发生的先后会导致不同的结果.<br>正确的 mirror 操作对应的 case 调整应该是:</p><ul><li><code>up</code> -&gt; <code>upMirrored</code></li><li><code>down</code> -&gt; <code>downMirrored</code></li><li><code>left</code> -&gt; <code>rightMirrored</code> <em>(Special)</em></li><li><code>right</code> -&gt; <code>leftMirrored</code> <em>(Special)</em></li></ul><h2 id="case-face-detection-中的坐标变换"><a class="markdownIt-Anchor" href="#case-face-detection-中的坐标变换"></a> Case: Face Detection 中的坐标变换</h2><p>问题: 拍摄一张人像, 在屏幕上显示该图像, 并框出这个图像中的人脸区域. 在不额外产生中间 image 的情况下如何解决.</p><p>流程简单描述如下:</p><ul><li><code>UIImagePicker</code>生成<code>UIImage</code>, 其<code>cgImage</code>为 unadjusted raw data.</li><li>执行 face detection 时, 同时传入 raw data 和 image orientation. 生成的 face bounds, 其 origin, 是在 unadjusted orientation 下, 相对于左下角的坐标.</li><li>要把人头crop出来, 需要:<ul><li>把 face bounds 的转成在 raw data image 坐标系下, origin 相对左上角的坐标</li><li>直接通过 raw data 建立 quartz image, 并用上述变换过 origin 的 bounds 执行 image crop, crop 的结果是未调整朝向的人脸 data.</li></ul></li><li>在 UI 上绘制图像和人脸对应的 view:<ul><li>用<code>UIImageView</code>渲染整张图像, 整个过程中涉及到 orientation 的地方由<code>UIKit</code> handle, 无难度.</li><li>用一个带边框的 subview/layer 表示人脸位置, 需要计算出, 把 raw data 按 orientation 执行一次 transform 后, 此时的 face bounds 距离旋转后的图片左上角的坐标.<ul><li>如果图片非1:1映射到屏幕, 则需要把上述坐标按图片真实尺寸和 view 的关系进行缩放/offset, 就可以得到最终的 face view/layer 的 frame.</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;ul class=&quot;markdownIt-TOC&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%83%8C%E6%99%AF&quot;&gt;背景&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BC%A0%E7%BB%9F%E7%9B%B8%E6%9C%BA&quot;&gt;传统相机&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#dslr&quot;&gt;DSLR&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AF%B9%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%BD%B1%E5%93%8D&quot;&gt;对图像算法的影响&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#orientation-tag-%E7%9A%84%E8%A1%A8%E7%A4%BA&quot;&gt;Orientation tag 的表示&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#raw-exif-%E4%BF%A1%E6%81%AF&quot;&gt;Raw exif 信息&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#apple-api&quot;&gt;Apple API&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#uiimage%E7%9B%B8%E5%85%B3-api&quot;&gt;&lt;code&gt;UIImage&lt;/code&gt;相关 API&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BD%BF%E7%94%A8-uikit-%E8%8E%B7%E5%8F%96uiimage%E6%97%B6-%E7%B3%BB%E7%BB%9F%E5%AF%B9imageorientation%E7%9A%84%E5%A1%AB%E5%85%85%E6%96%B9%E5%BC%8F&quot;&gt;使用 UIKit 获取&lt;code&gt;UIImage&lt;/code&gt;时, 系统对&lt;code&gt;imageOrientation&lt;/code&gt;的填充方式&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%9F%BA%E6%9C%AC%E7%9B%B8%E5%AF%B9%E5%85%B3%E7%B3%BB&quot;&gt;基本相对关系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%90%8E%E7%BD%AE%E6%91%84%E5%83%8F%E5%A4%B4&quot;&gt;后置摄像头&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%89%8D%E7%BD%AE%E6%91%84%E5%83%8F%E5%A4%B4&quot;&gt;前置摄像头&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#case-face-detection-%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2&quot;&gt;Case: Face Detection 中的坐标变换&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;原文成于2018年12月&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt; 背景&lt;/h2&gt;
&lt;p&gt;为什么存在 Image Orientation&lt;/p&gt;
&lt;h3 id=&quot;传统相机&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#传统相机&quot;&gt;&lt;/a&gt; 传统相机&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;传统相机横向拍摄, 胶卷和照片也按横向方位固定尺寸.&lt;/li&gt;
&lt;li&gt;拍竖直方向的景的时候, 摄影师把相机旋转90度, 拍到的原始照片是横向的.&lt;/li&gt;
&lt;li&gt;要正确还原现场的情况, 需要手动把照片旋转90度.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;dslr&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#dslr&quot;&gt;&lt;/a&gt; DSLR&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用户的持相机方式和需求没有本质变化.&lt;/li&gt;
&lt;li&gt;仍然需要外部额外信息来帮助确定怎么旋转拍得的图像.
&lt;ul&gt;
&lt;li&gt;用户使用相机上的 UI, 手动输入旋转信息.&lt;/li&gt;
&lt;li&gt;根据硬件的重力加速计自动确定方向.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于性能和效率原因, 并不会把 raw data 进行旋转生成一张新图片, 而是加上一个 tag, 这个 tag 就表示 image orientation.&lt;/li&gt;
&lt;li&gt;各端显示这样的图片时, 需要读取这个 tag, 并在渲染时给 raw data 加上一个 transform.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;对图像算法的影响&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#对图像算法的影响&quot;&gt;&lt;/a&gt; 对图像算法的影响&lt;/h2&gt;
&lt;p&gt;当对某个图像执行某些算法时, 除了必要的图像 data 信息, 还可能需要已知的 orientation 信息. 例如很多人脸检测算法, 在有先验的 orientation 知识时, 通常能有更好的效果. 例如, Apple 的 CoreImage 支持人脸检测, &lt;a href=&quot;https://developer.apple.com/documentation/coreimage/cidetectorimageorientation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;其 API 接受 orientation 参数&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://crystdragon.github.io/categories/notes/"/>
    
    <category term="Apple Platforms" scheme="https://crystdragon.github.io/categories/apple-platforms/"/>
    
    
    <category term="Image" scheme="https://crystdragon.github.io/tags/image/"/>
    
    <category term="UIKit" scheme="https://crystdragon.github.io/tags/uikit/"/>
    
    <category term="AVFoundation" scheme="https://crystdragon.github.io/tags/avfoundation/"/>
    
  </entry>
  
  <entry>
    <title>Computer Security Notes</title>
    <link href="https://crystdragon.github.io/2020/computer-security-notes/"/>
    <id>https://crystdragon.github.io/2020/computer-security-notes/</id>
    <published>2020-07-26T16:00:00.000Z</published>
    <updated>2020-07-28T09:00:02.992Z</updated>
    
    <content type="html"><![CDATA[<p><ul class="markdownIt-TOC"><li><a href="#%E5%AF%86%E7%A0%81%E5%AD%A6%E6%A6%82%E5%BF%B5">密码学概念</a></li><li><a href="#%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%AD%E7%9A%84-certificate-authority">互联网中的 Certificate Authority</a></li><li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84-chmod-chown">操作系统中的 chmod &amp; chown</a><ul><li><a href="#xcode-%E4%B8%8B-build-%E6%97%B6%E8%87%AA%E5%8A%A8%E5%8C%96%E6%8A%8A%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E5%88%B0%E5%8F%97%E9%99%90%E7%9B%AE%E5%BD%95">Xcode 下 build 时自动化把文件拷贝到受限目录</a></li></ul></li><li><a href="#case-mac-os-privilege-jobs">Case: Mac OS Privilege Jobs</a></li></ul></p><hr><p>原文成于2019年</p><hr><h2 id="密码学概念"><a class="markdownIt-Anchor" href="#密码学概念"></a> 密码学概念</h2><ul><li>对称加密<ul><li>需要 private 通道传递密钥.</li></ul></li><li>非对称加密<ul><li>实现 encryption (保证发送的东西没有别人知道): 传递方用接收方发布的公钥加密, 接收方用私钥解密.</li><li>实现 authentication (保证发送的人不会是别人):  传递把 message 用自己的私钥加密, 作为 signature 和 message 一起发给接收方, 接收方收到后用传递方早前公开提供的公钥对 signature 进行解密, 验证能还原到 message.</li></ul></li><li>混合加密: 用对称秘钥加密明文, 并用非对称秘钥加密对称秘钥.</li></ul><a id="more"></a><h2 id="互联网中的-certificate-authority"><a class="markdownIt-Anchor" href="#互联网中的-certificate-authority"></a> 互联网中的 Certificate Authority</h2><p>如果传递方只发送 public key 和 signature, 有一个隐患, 就是中间者攻击. 如果发送方和接收方之前没有任何通信过, 中间者可以使用自己的 private/public key, 全程把拦截到的信息转发给接收方, 让接收方误以为自己是发送方. 关键问题是要有一个机制, 让中间者无法把 public/private key pair 替换掉.</p><ul><li>使用证书, 传递方把自己的证书一起发送. 证书实际上是 authentication 的应用: 证书包含一些用 private key 加密的数据. 接收方可以验证 public key 和证书是对应的.<ul><li>中间者拦截到真正的证书后, 如果选择向发送方透传这个包含真的 public key 的证书, 他就无法达到他的非法目的. 因为一旦这样, 整个通信过程就会使用这个证书的 key pair, 中间人就无法作假.</li><li>中间者如果选择发送自己设法伪造的证书, 就不可能不被察觉. 因为接收方有办法发觉这个证书的伪造之处.</li></ul></li><li>要确定证书是正当的还是伪造的, 关键在于需要有权威机构签发 (issue) 证书.<ul><li>世界上有可以数尽的根认证机构, 其各有自认证的根证书.</li><li>这些公司按树型关系逐级会签发证书给别的机构, 子证书和父证书的所属关系是可以合法验证的, 造假者不可能自己单独建一个假的子证书关联到父证书.<ul><li>验证某个子证书是由父证书签发, 同样也是 authentication 的应用: 验证者可以使用父证书公开的 public key 在本地确认是否可以正确 decrypt 子证书.</li></ul></li><li>软件公司在自己的 Browser/Operating System 中加入最顶级的根证书</li><li>当收到发送方传来的证书时, 按照链式关系验证证书是否最终会导向根证书, 如果 ok 则信任, 否则交由用户处理(称之为自认证证书).</li></ul></li><li>互联网证书系统实际上是把&quot;public key公开&quot;这一步, 转移到以权威机构签发证书, 来解决问题.</li></ul><p>日常开发中的 Charles, 正是中间人攻击的一种<a href="https://www.charlesproxy.com/documentation/using-charles/ssl-certificates/" target="_blank" rel="noopener">正面应用</a>.</p><ul><li>Charles 自己有自己的 root 证书.</li><li>在检测到对某个域名的访问时, Charles 会针对该域名基于 root 证书现场创建一个子证书, 并把该证书提供给发送方设备.<ul><li>设备需要手动信任该证书.</li><li>也可以提前把 Charles 的 root 证书添加到信任列表.</li></ul></li><li>发送方设备使用 Charles 的证书对应的 public key 加密后, Charles 有能力 decrypt, 并用真正的服务端 public key 重新加密, 发送给服务端.</li></ul><h2 id="操作系统中的-chmod-chown"><a class="markdownIt-Anchor" href="#操作系统中的-chmod-chown"></a> 操作系统中的 chmod &amp; chown</h2><p>unix下每个文件都有3类不同的访问者: user, group, other.<br>对每类访问者都支持三种不同操作: read, write, execute</p><ul><li>chmod: 用来改变文件针对不同访问者的访问权限</li><li>chown: 用来改变文件所属的user</li></ul><h3 id="xcode-下-build-时自动化把文件拷贝到受限目录"><a class="markdownIt-Anchor" href="#xcode-下-build-时自动化把文件拷贝到受限目录"></a> Xcode 下 build 时自动化把文件拷贝到受限目录</h3><ul><li>增加 copy file phase. 无法解决&quot;permission denied&quot;问题.</li><li>依赖 Deployment 设置中的 installation location. 不一定能满足需求, 因为它会在目标位置建立完整的目录, 也会面临permission问题.</li><li>目前找到的唯一的办法: 使用 custom script phase, 里面用<code>sudo cp</code>来解决.<ul><li>但是 Xcode 执行 script 的环境默认不支持 sudo, 也不可能交互式地输入密码, 所以需要用<code>sudo -A</code>指定一个 password 输出程序.</li><li>这个文件可以直接用shell写, 内容是<code>echo password</code>即可, 但注意这个文件需要对 xcode 而言有 x 权限</li></ul></li></ul><h2 id="case-mac-os-privilege-jobs"><a class="markdownIt-Anchor" href="#case-mac-os-privilege-jobs"></a> Case: Mac OS Privilege Jobs</h2><p>我们的 mac app 经常需要临时获得特权来访问一些受保护的系统资源. 当然需要由用户的确认, 但我们又不想把整个 app 权限提的太高. 因此可以使用2个进程, 一个 daemon , 一个 main app. Main app 把 daemon 作为 privilege helper tools 注册给系统, 系统(经过用户确认)安装到位后, 两者进行 IPC 传递数据.</p><p>相关 frameworks:</p><ul><li>Security - Authorization Services: 权限相关的定义.</li><li>ServiceManagement: 注册privilege tools.</li><li>XPC: 用于轻量级的进程间通信.</li></ul><p>(注: 不建议再使用AuthorizationExecuteWithPrivileges, 此方法因为没有对待启动的tool作更严格的校验, 已被标记deprecated.)</p><p>这些库用到了的 mac 系统技术有:</p><ul><li>launchd: 管理系统daemon和agent的启动.</li><li>launchctl: 可以解析相关service的plist.</li></ul><p>参考:</p><ul><li><a href="http://www.stevestreeting.com/2011/11/25/escalating-privileges-on-mac-os-x-securely-and-without-using-deprecated-methods/" target="_blank" rel="noopener">Useful References</a></li><li><a href="https://developer.apple.com/library/content/documentation/Security/Conceptual/authorization_concepts/03authtasks/authtasks.html#//apple_ref/doc/uid/TP30000995-CH206-TPXREF33" target="_blank" rel="noopener">Authorization Service Programming Guide</a></li><li><a href="https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#//apple_ref/doc/uid/10000172i-SW6-SW1" target="_blank" rel="noopener">Daemons and Services Programming Guide</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;ul class=&quot;markdownIt-TOC&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AF%86%E7%A0%81%E5%AD%A6%E6%A6%82%E5%BF%B5&quot;&gt;密码学概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%AD%E7%9A%84-certificate-authority&quot;&gt;互联网中的 Certificate Authority&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84-chmod-chown&quot;&gt;操作系统中的 chmod &amp;amp; chown&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#xcode-%E4%B8%8B-build-%E6%97%B6%E8%87%AA%E5%8A%A8%E5%8C%96%E6%8A%8A%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E5%88%B0%E5%8F%97%E9%99%90%E7%9B%AE%E5%BD%95&quot;&gt;Xcode 下 build 时自动化把文件拷贝到受限目录&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#case-mac-os-privilege-jobs&quot;&gt;Case: Mac OS Privilege Jobs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;原文成于2019年&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;密码学概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#密码学概念&quot;&gt;&lt;/a&gt; 密码学概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;对称加密
&lt;ul&gt;
&lt;li&gt;需要 private 通道传递密钥.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非对称加密
&lt;ul&gt;
&lt;li&gt;实现 encryption (保证发送的东西没有别人知道): 传递方用接收方发布的公钥加密, 接收方用私钥解密.&lt;/li&gt;
&lt;li&gt;实现 authentication (保证发送的人不会是别人):  传递把 message 用自己的私钥加密, 作为 signature 和 message 一起发给接收方, 接收方收到后用传递方早前公开提供的公钥对 signature 进行解密, 验证能还原到 message.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;混合加密: 用对称秘钥加密明文, 并用非对称秘钥加密对称秘钥.&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://crystdragon.github.io/categories/notes/"/>
    
    <category term="Computer Systems" scheme="https://crystdragon.github.io/categories/computer-systems/"/>
    
    
    <category term="Cryptography" scheme="https://crystdragon.github.io/tags/cryptography/"/>
    
    <category term="Apple Platforms" scheme="https://crystdragon.github.io/tags/apple-platforms/"/>
    
  </entry>
  
  <entry>
    <title>Deallocation 中的线程安全</title>
    <link href="https://crystdragon.github.io/2020/deallocation-thread-safety/"/>
    <id>https://crystdragon.github.io/2020/deallocation-thread-safety/</id>
    <published>2020-07-26T16:00:00.000Z</published>
    <updated>2020-07-28T11:26:44.145Z</updated>
    
    <content type="html"><![CDATA[<p><ul class="markdownIt-TOC"><li><a href="#%E8%83%8C%E6%99%AF">背景</a></li><li><a href="#%E5%88%86%E6%9E%90">分析</a><ul><li><a href="#%E6%97%A0%E7%BA%BF%E7%A8%8B%E7%AB%9E%E4%BA%89">无线程竞争</a></li><li><a href="#%E6%9C%89%E7%BA%BF%E7%A8%8B%E7%AB%9E%E4%BA%89">有线程竞争</a><ul><li><a href="#%E5%BC%BA%E5%BC%95%E7%94%A8">强引用</a></li><li><a href="#%E5%BC%B1%E5%BC%95%E7%94%A8">弱引用</a></li><li><a href="#unsafe%E5%BC%95%E7%94%A8">unsafe引用</a></li></ul></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></p><hr><p>原文成于2017年11月</p><hr><h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>最近在浏览 Swift Talk 的过程中, 思考了一个很有意思的问题.</p><p>如果一个对象通过<code>NotificationCenter</code>注册了一个通知, 然后在这个对象的<code>deinit</code>方法中执行了<code>removeObserver</code>. 假如在对象调用<code>deinit</code>的过程中对应的事件发生了, 并产生了一个通知, 此时会有什么现象? 当事件发生/投递的线程和对象<code>deinit</code>的线程不是一个线程时, 会导致崩溃吗? <a href="https://talk.objc.io/episodes/S01E28-typed-notifications-part-2" target="_blank" rel="noopener">Swift Talk #28最后5分钟内容</a></p><p>这个问题我觉得很有意思, 之前都没有意识到过.</p><p>事实上虽然这个问题是在&quot;Swift Talk&quot;中抛出, 但是并不是Swift独有的, OC 下的<code>dealloc</code>方法同样有这个问题. 另外, 虽然问题是以 Notification 为例, 但显然问题并不限于通知, 任何别的含有通知/回调机制的场景都会面临同样的问题.</p><a id="more"></a><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>首先需要明确的是, 从安全角度来讲, 是有必要反注册的. 即使新的 API 也许不要求我们开发者显式调用<code>removeObserver</code>, 其内部也一定在合适的时机执行了等价的反注册. 下面都是以调用了<code>removeObserver</code>这个为前提进行讨论.</p><p>其次, 考虑一下, 如果这边有问题, 会是什么类型的问题? 我认为至少可能有以下2类问题</p><ul><li>线程不安全. 如果这个对象的类没有设计成线程安全, 那么本身在2个不同的线程调用<em>任何</em>成员方法都是不安全的, 因此<code>deinit</code>和回调方法两者自然会产生竞争.</li><li>野指针. 注意到和普通的成员方法不同, <code>deinit</code>有特殊性. 一旦<code>deinit</code>开始调用, 意味着这个对象已经进入不稳定的状态, 此时这个对象的任何属性/ivar可能都开始瓦解. 一旦对这个对象的成员进行其他操作, 极有可能访问到无效的内存区域, 产生更严重的问题.</li></ul><p>这篇文章, 主要是分析上述2个问题中的<em>后者</em>是否可能出现. 下面把问题分成几类来考虑.</p><h3 id="无线程竞争"><a class="markdownIt-Anchor" href="#无线程竞争"></a> 无线程竞争</h3><p>也就是说<code>deinit</code>调用和 notification 的投递发生在一个线程的情况.</p><p>可以直接给出结论: 没有问题. 这是因为如果两者是在一个线程发生, 那么一定有先来后到的顺序, <code>deinit</code>和投递 notification 不可能同时执行.</p><ul><li>如果<code>deinit</code>先执行, 那么<code>removeObserver</code>会先被调用, 此时一个良好<br>的<code>NotificationCenter</code>的实现就会断开对这个对象的任何引用, 也就保证了, 当后续事件产生时, 不可能再通知/回调这个对象.</li><li>如果事件先产生并投递到这个对象, 再<code>deinit</code>. 只要这个对象对事件的消费/响应都是立即的(非 异步的), 自然没有任何问题.</li></ul><h3 id="有线程竞争"><a class="markdownIt-Anchor" href="#有线程竞争"></a> 有线程竞争</h3><p>也就是说<code>deinit</code>调用和 notification 的投递不是运行在同一个线程.</p><p>为了专注分析, 我们假设这个对象的类已经是设计成线程安全的, 也就是说在不同的线程同时调用这个类的不同方法本身没有任何问题. 即假设&quot;不会因为不在同一个线程调用,本身就导致线程不安全&quot;.</p><p>和上面&quot;无线程竞争&quot;区别的一点是, 讨论<code>deinit</code>和事件投递谁先谁后已经没有意义了, 因为这2个调用既然发生在2个线程, 一定有可能在执行时间上重叠. 我们应该讨论的是<code>deinit</code>中<br>的<code>removeObserver</code>调用期和事件投递的先后顺序.<br>同样为了专注分析, 我们还要假设的是<code>NotificationCenter</code>的实现也是线程安全的, 即&quot;某个事件产生&quot;和&quot;这个事件的监听者调用<code>removeObserver</code>&quot;发生在不同的线程时, 事件的投递不会出现问题. 一个合理的<code>NotificationCenter</code>的实现在遇到这样的情况时, 应该根据内部原子操作发生的顺序决定监听者能收到这个事件或收不到这个事件.</p><p>这时候, 我们就需要深入考虑<code>NotificationCenter</code>的实现了. 应该意识到一个显然的事实, 既然发生的事件可以通知到这个对象, 那么<code>NotificationCenter</code>一定有一个指针/引用指向这个对象, 因为如果连这个引用都不存在, 那么根本不可能和这个对象产生任何关联. 下文的分析就按这个引用的类型来进行划分.</p><h4 id="强引用"><a class="markdownIt-Anchor" href="#强引用"></a> 强引用</h4><p>如果<code>NotificationCenter</code>的实现, 是在<code>addObserver</code>之后, 保留了一个对观察者的强引用.</p><p>那么, 肯定不会产生<em>野指针</em>的问题. 因为只要<code>NotificationCenter</code>的实现者没有犯2, 自作主张去掉了对事件监听者的引用, 那么在调用<code>removeObserver</code>之前, 这个对象的引用计数一定是大于0的.<br>然而, 假若<code>NotificationCenter</code>的实现真的使用了强引用来保存监听者, 那么我们再也不能在监听者的<code>deinit</code>中执行<code>removeObserver</code>, 但凡偏要这么做, 因为强引用的缘故, 这个<code>deinit</code>永远没有机会被调用, 内存就泄露了. 我们不得不考虑在别的合适时机主动调用<code>removeObserver</code>, 这样对于类库的使用者来言是一种负担.<br>事实上官方<code>NotificationCenter</code>也没有实现成使用强引用来保存监听者.</p><h4 id="弱引用"><a class="markdownIt-Anchor" href="#弱引用"></a> 弱引用</h4><p>如果<code>NotificationCenter</code>的实现, 是在<code>addObserver</code>之后, 保留了一个对这个对象的弱引用.</p><p>弱应用和强引用不同, 那么可能发生问题中的现象吗? 如果<code>NotificationCenter</code>在事件产生后能通知到这个对象, 意味着在通知/回调的瞬间, 这个对象还是活着的. 那么当回调方法开始调用之后, 但处理完之前, 有可能所有对这个对象的强引用消失, 从而在另一个线程触发了<code>deinit</code>吗?</p><p>按<code>removeObserver</code>调用和事件投递发生的先后分为两类.</p><ul><li>假如事件的投递先于<code>deinit</code>中<code>removeObserver</code>执行. 那么, 在事件产生的瞬间, 对象一定是活着的, 然后对象无论怎么处理这个事件, 只要<code>NotificationCenter</code>保证对象在回调结束前始终保证对监听者有一个 strong 引用, 那么在处理完成之前, 监听者<code>deinit</code>是不可能被调用的, 因此不会产生时序重叠. 而这是很容易保证的, 一方面无论是 Swift 还是 OC, 所有方法调用开始时的引用类型入参默认 +1 reference count, 因此<code>NotificationCenter</code>无论是直接向监听者发送方法, 还是把监听者作为参数传给回调方法, 在投递完成前都不会产生野指针问题.</li><li>假如<code>deinit</code>中<code>removeObserver</code>的执行先于事件投递呢. …事实上, 这个 case 是不可能出现的, 但出现的原因和强引用的情况不同, 并不是&quot;<code>deinit</code>不可能被调用&quot;, 而是事件不可能完成投递. ARC 保证, 一旦一个对象的开始销毁, 所有对这个对象的弱引用都会在这个对象的<code>deinit</code>调用之前, 率先被设置成<code>nil</code>. 换句话说, 一旦监听者的<code>deinit</code>开始被触发, 即使<code>removeObserver</code>没有在第一 时间被调用, <code>NotificationCenter</code>也没有任何可能性知晓监听者的存在了, 从而没有任何办法触发通知到这个对象, 问题自然也不可能产生.</li></ul><p>事实上, 新版本的 iOS SDK (<a href="https://stackoverflow.com/questions/41119725/notificationcenter-addobserver/41120287%2341120287" target="_blank" rel="noopener">没记错的话是 &gt;= 9.0</a>) 中<code>NotificationCenter</code>就是使用了对监听者的 weak reference/类似技术来实现的. 这是皆大欢喜的局面了.</p><h4 id="unsafe引用"><a class="markdownIt-Anchor" href="#unsafe引用"></a> unsafe引用</h4><p>最后来考虑一下当今 ARC 环境下很少出现, 但不是不可能的情况: <code>NotificationCenter</code>的实现, 是在<code>addObserver</code>之后, 保留了一个对这个对象的 unsafe 引用.<br>注意: 即使我们在100%使用 ARC 的情况下编写 iOS 程序, 仍然有可能遇到这个情况, 这是因为即使我 们保证我们的代码里不出现任何 unsafe 引用, 我们链接到的官方 Cocoa 类库的内部仍然有可能因为历史原因使用了 unsafe 引用. 事实上, 在旧版本的 SDK 中, <code>NotificationCenter</code> 应该就是这样的.</p><p><code>NotificationCenter</code>保存对监听者的 unsafe 引用, 和使用弱引用相比, 区别在于: 如果对象被释放, <code>NotificationCenter</code>仍然有一个野指针指向这个对象的尸骸, 因此确实可能在<code>deinit</code>开始调用但在<code>removeObserver</code>被调用前, 事件投递到监听者, 但在处理这个事件的过程中<code>this</code>指针所指向的内存区域已经部分/全部失效了.<br>事实上, 在多线程环境下对触发了对象的<code>deinit</code>是 Cocoa 早期开发一个经典的崩溃来源, 这类被称为&quot;The Dealloc Problem&quot;的问题当时非常难以100%避免. (<a href="https://www.objc.io/issues/2-concurrency/thread-safe-class-design/#the-deallocation-problem" target="_blank" rel="noopener">“The Dealloc Problem”</a><a href="https://developer.apple.com/library/archive/technotes/tn2109/_index.html#//apple_ref/doc/uid/DTS40010274-CH1-SUBSECTION11" target="_blank" rel="noopener">多数情况发生在UIKit</a>, 因为相当一部分UIKit组件不允许在非主线程被释放, 和此处问题背后的 principle 是相关的.)</p><p>当然也不是没有解决办法, 例如可以:</p><ul><li>消除多线程的可能性, 以<code>NotificationCenter</code>为例, 它有<a href="https://developer.apple.com/documentation/foundation/notificationcenter/1411723-addobserver" target="_blank" rel="noopener">一个 API</a> 允许我们指定消息投递发生的 queue. 即使消息产生在另一个 queue, <code>NotificationCenter</code>也会在我们指定的 queue 回调我们的方法, 如果我们可以保证对这个对象的所有操作也在这同一个线程中进行, 那么自然我们就从根本上避开了多线程的问题.</li><li>另一个消除多线程的方法, 是在<code>deinit</code>中进行一些阻塞操作. 例如假设事件产生在 main thread, 但是这个对象的最后一个强引用消失在 non-main thread. 此时有些人会选择在对象的<code>deinit</code>中使<br>用<code>DispatchQueue.sync()</code> / <code>NSObject.perform(_:on:with:waitUntilDone:)</code> sync 到 main thread 结束来规避问题. 诚然这种方式也可以解决问题, 但也带来了 deadlock 的风险.</li><li>最后一个方式是手动尽早消除<code>NotificationCenter</code>对监听者的引用, 例如尽早(在保证监听者一定存活的时候)调用<code>removeObserver</code>来断开两者的引用. 这种方式有时候只是尽可能减小问题发生的概率空间, 而没有完全消除问题, 因为并不是所有情况下你都可以保证你说的多早是不是够早.</li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>说了这么多, 并不是让我们人人自危, 让我们怀疑自己写的最普遍最平实的代码. 但确实值得我们作 一些思考, 而这些思考也许可以帮助加深对 reference counting, thread safety 的理解.</p><p><strong>TL,DR:</strong></p><ul><li>在使用需要主动反注册的回调机制时, 有必要思考一下调用反注册方法的时机. 如果在<code>deinit</code>中进行反注册, 并不是完全无风险的, 在涉及到多线程的情况下, 应该思考一下安全问题.</li><li>在极大多数情况下, 如果涉及到多线程的回调, 我们只要保证监听方和被监听方各自的类是线程安全即可. 在不产生循环引用的前提下, 是在<code>deinit</code>中反注册还是在别的地方反注册并不是一个 big deal.</li><li>在非 ARC 下, 需要作特殊注意, 在<code>deinit</code>中反注册有可能产生&quot;The Dealloc Problem&quot;. 此时需要一些额外的手段来尽可能规避问题. 感谢上帝, <a href="https://stackoverflow.com/questions/13910613/nsnotificationcenter-removeobserver-in-dealloc-and-thread-safety" target="_blank" rel="noopener">这类问题</a>现在已经非常罕见了.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;ul class=&quot;markdownIt-TOC&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%83%8C%E6%99%AF&quot;&gt;背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%88%86%E6%9E%90&quot;&gt;分析&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%97%A0%E7%BA%BF%E7%A8%8B%E7%AB%9E%E4%BA%89&quot;&gt;无线程竞争&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9C%89%E7%BA%BF%E7%A8%8B%E7%AB%9E%E4%BA%89&quot;&gt;有线程竞争&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%BC%BA%E5%BC%95%E7%94%A8&quot;&gt;强引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%BC%B1%E5%BC%95%E7%94%A8&quot;&gt;弱引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#unsafe%E5%BC%95%E7%94%A8&quot;&gt;unsafe引用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E7%BB%93&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;原文成于2017年11月&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt; 背景&lt;/h2&gt;
&lt;p&gt;最近在浏览 Swift Talk 的过程中, 思考了一个很有意思的问题.&lt;/p&gt;
&lt;p&gt;如果一个对象通过&lt;code&gt;NotificationCenter&lt;/code&gt;注册了一个通知, 然后在这个对象的&lt;code&gt;deinit&lt;/code&gt;方法中执行了&lt;code&gt;removeObserver&lt;/code&gt;. 假如在对象调用&lt;code&gt;deinit&lt;/code&gt;的过程中对应的事件发生了, 并产生了一个通知, 此时会有什么现象? 当事件发生/投递的线程和对象&lt;code&gt;deinit&lt;/code&gt;的线程不是一个线程时, 会导致崩溃吗? &lt;a href=&quot;https://talk.objc.io/episodes/S01E28-typed-notifications-part-2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift Talk #28最后5分钟内容&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个问题我觉得很有意思, 之前都没有意识到过.&lt;/p&gt;
&lt;p&gt;事实上虽然这个问题是在&amp;quot;Swift Talk&amp;quot;中抛出, 但是并不是Swift独有的, OC 下的&lt;code&gt;dealloc&lt;/code&gt;方法同样有这个问题. 另外, 虽然问题是以 Notification 为例, 但显然问题并不限于通知, 任何别的含有通知/回调机制的场景都会面临同样的问题.&lt;/p&gt;</summary>
    
    
    
    <category term="Apple Platforms" scheme="https://crystdragon.github.io/categories/apple-platforms/"/>
    
    <category term="Architecture" scheme="https://crystdragon.github.io/categories/architecture/"/>
    
    
    <category term="Thread Safety" scheme="https://crystdragon.github.io/tags/thread-safety/"/>
    
    <category term="ARC" scheme="https://crystdragon.github.io/tags/arc/"/>
    
    <category term="NotificationCenter" scheme="https://crystdragon.github.io/tags/notificationcenter/"/>
    
  </entry>
  
  <entry>
    <title>Swift Practices &amp; Perls (1)</title>
    <link href="https://crystdragon.github.io/2020/swift-practices-perls-1/"/>
    <id>https://crystdragon.github.io/2020/swift-practices-perls-1/</id>
    <published>2020-07-23T15:23:51.000Z</published>
    <updated>2020-11-12T11:37:44.119Z</updated>
    
    <content type="html"><![CDATA[<p><ul class="markdownIt-TOC"><li><a href="#%E6%99%AE%E9%80%9A-practices">普通 Practices</a><ul><li><a href="#availability-checks">Availability checks</a></li><li><a href="#%E6%B4%BB%E7%94%A8-string-backed-enum">活用 “String-backed” enum</a><ul><li><a href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86">背景知识</a></li><li><a href="#%E6%A1%88%E4%BE%8B">案例</a></li></ul></li></ul></li><li><a href="#tricks-patterns">Tricks &amp; Patterns</a><ul><li><a href="#%E7%BB%99-protocol-%E5%A2%9E%E5%8A%A0-recursive-constraints-before-swift-41">给 protocol 增加 recursive constraints (before Swift 4.1)</a></li><li><a href="#%E6%B3%9B%E5%9E%8B%E5%AF%B9%E8%B1%A1%E6%8E%92%E9%99%A4%E7%89%B9%E4%BE%8B%E8%B0%83%E7%94%A8">泛型对象排除特例调用</a><ul><li><a href="#%E9%97%AE%E9%A2%98">问题</a></li><li><a href="#%E5%9C%BA%E6%99%AF">场景</a></li><li><a href="#%E5%AE%9E%E7%8E%B0">实现</a></li></ul></li><li><a href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E6%8C%89%E6%9D%A1%E4%BB%B6%E9%81%B5%E5%BE%AA-protocol-before-swift-41">泛型类型按条件遵循 protocol (before Swift 4.1)</a></li></ul></li></ul></p><hr><p>原文成于2018年</p><hr><p>本文积累学习 Swift 过程中获取到的好技巧, 以及 Swift Standard Library 使用的优秀范式 (tricks).</p><h2 id="普通-practices"><a class="markdownIt-Anchor" href="#普通-practices"></a> 普通 Practices</h2><h3 id="availability-checks"><a class="markdownIt-Anchor" href="#availability-checks"></a> Availability checks</h3><p>使用 availability checks 将超出指定的&quot;Base SDK&quot;版本的代码块隔离起来. 在运行时, 系统会根据运行环境动态 check 该代码是否执行.</p><ul><li><code>@available(iOS 9.0, *)</code>, method, type 定义时.</li><li><code>if #available(iOS 9.0, *)</code>, 使用 method, type 时.</li><li>支持 guard 作为 early exit.</li></ul><p>可以替代相对应的早期的以下调用:<br><code>UIDevice.current.systemVersion.compare(&quot;9.0&quot;, options: .numeric) == .orderedAscending</code></p><h3 id="活用-string-backed-enum"><a class="markdownIt-Anchor" href="#活用-string-backed-enum"></a> 活用 “String-backed” enum</h3><h4 id="背景知识"><a class="markdownIt-Anchor" href="#背景知识"></a> 背景知识</h4><p>在众多基于 raw value 的 enum 中, raw value 是<code>String</code>的最为特殊, 因为这样的 enum 在定义各个 case 时, 可以省去显式写出用来初始化该 enum 的 raw value. 这种情况下, 编译器默认追加代码, 使用各个 case identifier 的同名字符串作为 raw value.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 各行 case 可以省略 // 之后的部分</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ImageIdentifier</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> centerButton <span class="comment">// = "centerButton"</span></span><br><span class="line">  <span class="keyword">case</span> myFavorites <span class="comment">// = "myFavorites"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一方面, 这样的 enum 默认遵循<code>RawRepresentable</code>, 且关联类型<code>RawValue == String</code>. 这方便我们对于一系列有相同特征的 enum 依靠 protocol 提供统一操作.</p><h4 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例</h4><p>下述技巧最早出现于<a href="https://web.archive.org/web/20200108191946/https://developer.apple.com/videos/play/wwdc2015/411/" target="_blank" rel="noopener">WWDC 2015, session 403</a>.<br>该 video 已经被 apple 从公开列表中移除, 此处提供的是 web.archive 上的缓存.<br>也可以尝试直接获取 <a href="https://devstreaming-cdn.apple.com/videos/wwdc/2015/4119flfsnsgmlfy/411/411_hd_swift_in_practice.mp4?dl=1" target="_blank" rel="noopener">video</a> 和 <a href="https://devstreaming-cdn.apple.com/videos/wwdc/2015/4119flfsnsgmlfy/411/411_swift_in_practice.pdf?dl=1" target="_blank" rel="noopener">pdf</a>.</p><a id="more"></a><p>在使用 segue 的 app 中每一个<code>UIViewController</code>都含有一组 segue identifier, 通过调用<code>func performSegue(withIdentifier identifier: String, sender: Any?)</code>来执行页面跳转.</p><p>但是直接调用该方法有风险: 传入的<code>identifier</code>有可能有拼写错误. 因此容易想到, 定义一个使用<code>String</code>作为 raw value 的 enum, 并同时给<code>UIViewController</code>增加一个接受该 enum 的重载方法.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SegueIdentifier</span>: <span class="title">String</span></span>&#123;</span><br><span class="line">  <span class="keyword">case</span> jumpToHome</span><br><span class="line">  <span class="keyword">case</span> jumpToMyFavorites</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">HomeViewController</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">performSegue</span><span class="params">(identifer: SegueIdentifier)</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.performSegue(withIdentifier: identifer.rawValue, sender: <span class="literal">nil</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时</span></span><br><span class="line">performSegue(identifer: .jumpToHome)</span><br></pre></td></tr></table></figure><p>但仅仅如此, 有多个副作用</p><ul><li>不同的 view controller 理所当然有不同的 segue, 因此应该给不同的 view controller 定义不同的<code>SegueIdentifier</code> enum, 使他们彼此独立</li><li>既然必须存在多个<code>SegueIdentifier</code> 彼此独立, 那么就不得不针对每种<code>SegueIdentifier</code>单独提供一个<code>performSegue</code>的重载方法</li></ul><p>可以看到这样虽然提供了一种 type safe 的调用方法, 但是显著增加了工作量. 为了解决这个问题, 可以抽象出一个 protocol, 表示包含<code>SegueIdentifier</code>的 view controller, 进而针对该 protocol 统一增加一个方法即可.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里使用的 swift 语法, 可以直接给 protocol 的遵循者增加约束</span></span><br><span class="line"><span class="comment">// 在最初的 WWDC session 中还不支持这么做</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SegueNavigation</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">associatedtype</span> <span class="type">SegueIdentifier</span>: <span class="type">RawRepresentable</span> <span class="keyword">where</span> <span class="type">SegueIdentifier</span>.<span class="type">RawValue</span> == <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">performSegue</span><span class="params">(identifier: SegueIdentifier)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SegueNavigation</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">performSegue</span><span class="params">(identifier: SegueIdentifier)</span></span> &#123;</span><br><span class="line">    performSegue(withIdentifier: identifier.rawValue, sender: <span class="literal">nil</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时, 只要任意<code>UIViewController</code>, 通过提供自己 local 的<code>SegueIdentifier</code>, 就可以遵循<code>SegueNavigation</code>, 进而可以调用 type safe 的<code>func performSegue(identifier: SegueIdentifier)</code>方法.</p><h2 id="tricks-patterns"><a class="markdownIt-Anchor" href="#tricks-patterns"></a> Tricks &amp; Patterns</h2><p>由于 Swift 语言在不断变化之中, 很多将来加入的语法特性在当下版本没有直接对应的表达方式. 但凭借 Swift 已有的丰富的 generics 和 protocol 表达技巧, 可以实现一些等价的功能 (虽然可能并不优雅).</p><h3 id="给-protocol-增加-recursive-constraints-before-swift-41"><a class="markdownIt-Anchor" href="#给-protocol-增加-recursive-constraints-before-swift-41"></a> 给 protocol 增加 recursive constraints (before Swift 4.1)</h3><p>定义 Swift 的 protocol 时, 可以要求遵循者同时提供<code>associatedtype</code>, 该<code>associatedtype</code>可以附带一些额外约束, 例如<code>: SomeType</code>, <code>where ...</code>. 当前版本下, 这样的约束内允许递归引用到 protocol 本身<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">associatedtype</span> <span class="type">T</span>: <span class="type">A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在允许 associated type 递归引用前, 为了实现该功能, 使用了以下技巧.</p><p>(1) 先定义一个和<code>A</code>有相同接口或大部分关键接口的&quot;隐形 protocol&quot;.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">__PrivateA</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里包含了 A 本来的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) 然后使<code>A</code>本身继承这个 protocol, 并要求 associatedtype 也遵循这个 protocol.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">A</span>: <span class="title">__PrivateA</span> </span>&#123;</span><br><span class="line">  <span class="keyword">associatedtype</span> <span class="type">T</span>: __PrivateA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3) 此时所有引用<code>A</code>和<code>A.T</code>的地方, 都可以调用到 <code>__PrivateA</code> 中的那些方法了</p><p>这种避免显式出现 recursion 的方式, 虽然可以解决语法问题, 但带来的后果就是多了不得不暴露给用户的中间层. 在 Swift 4.1 之前的标准库中, <code>Collection</code> 就通过该技巧定义了<code>SubSequence</code>和<code>Indices</code>这2个 associated type. 诚然这也给当时的学习者带来了一些困难:</p><ul><li>太多 protocol, 不容易理清类库关联性.</li><li>这种引入的中间层 protocol 语法上来讲是可见的, 但是标准库在导出 interface 时有一个 hack 步骤: 把所有&quot;__&quot;开头的声明 strip 掉了, 此时这个方法可以被调用, 但不会出现在 interface 和 documentation 里. 这反而导致这个 protocol 中的某些关键方法无法被使用者注意到. 例如<code>Collection</code>中有一个关键方法<code>func index(after i: Index) -&gt; Index</code>, 在当时正因为定义在实现此 trick 对应的<code>_IndexableBase</code>中, 导致无法在文档中查询.</li></ul><h3 id="泛型对象排除特例调用"><a class="markdownIt-Anchor" href="#泛型对象排除特例调用"></a> 泛型对象排除特例调用</h3><h4 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h4><p>一般而言, 经常需要在泛型类型的模板参数满足某个条件时, 增加一些特例调用. 这时候我们可以通过带限制条件的 extension 给这个类型扩展方法.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Container</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Container</span> <span class="title">where</span> <span class="title">T</span> == <span class="title">Int</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">special</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Container</span>&lt;<span class="type">Int</span>&gt;().special()<span class="comment">// OK</span></span><br><span class="line"><span class="type">Container</span>&lt;<span class="type">Double</span>&gt;().special()<span class="comment">// Compiler Error!</span></span><br><span class="line"><span class="type">Container</span>&lt;<span class="type">String</span>&gt;().special()<span class="comment">// Compiler Error!</span></span><br></pre></td></tr></table></figure><p>这边提出的是一个反向问题: 对于某个泛型类型, 要求模板参数在某个条件下, 不能调用某个方法. 这个乍看 Swift 不可能支持的需求, 在某种程度上可以实现.</p><h4 id="场景"><a class="markdownIt-Anchor" href="#场景"></a> 场景</h4><p>这个需求貌似不符合逻辑, 但 Swift Standard Library 中就有曾经有个这样的例子. 在之前版本的 Swift 中, <code>CountableRange</code>用来表示可以离散取值的闭区间. 例如<code>0..&lt;10</code>就是一个<code>CountableRange</code>. 很自然地, <code>CountableRange</code>可以遵循<code>Collection</code>. 既然可以遵循<code>Collection</code>, 那么接下来就需要确定<code>CountableRange</code>的<code>Index</code>.</p><p>在 Swift 中, 一个<code>Collection</code>的<code>Index</code>, 不一定为<code>Int</code>; 即使是<code>Int</code>, 也不一定从0开始. 并且, <code>Collection</code>和其<code>SubSequence</code>之间, 应该存在<code>Index</code>的复用关系. 例如:</p><ul><li><code>Array</code>的<code>SubSequence</code>: <code>ArraySlice</code>, 复用<code>Array</code>的 index, 即<code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].dropFirst()</code>的<code>startIndex</code>是1, 而不是0.</li><li><code>String</code>的<code>SubSequence</code>: <code>SubString</code>, 复用<code>String</code>的 index, 即<code>&quot;hello word&quot;.prefix(6)</code>的<code>endIndex</code>, 在原来 string 中可以索引出&quot;w&quot;.</li></ul><p><code>CountableRange</code>也应如此, 那么<code>(-10..&lt;10)[0]</code> 应该是多少呢, 如果把<code>CountableRange</code>的<code>firstIndex</code>一律定位0, 那么上述表达式会返回 range 中的第一个值&quot;-10&quot;. 但这是不符合<code>Collection</code>约定的, 因为<code>(-10..&lt;10).dropFirst()</code>的结果<code>-9..&lt;10</code>, 仍然是一个<code>CountableRange</code>. 但它的<code>firstIndex</code>显然不应该是0, 因为<code>(-9..&lt;10)[0]</code>会返回9, 这就违反<code>Collection</code>和<code>SubSequence</code>中, 同一个 index 应该取得同样的 element 这个约定.</p><p>所以 Swift Standard Library 决定, 针对一个<code>CountableRange</code>: <code>a..&lt;b</code>, 使用<code>a</code>作为其 <code>firstIndex</code>, 从而<code>(a..&lt;b)[a] == a</code>. 这一个理性但也许出人意料的表现, 确实可能导致一部分人的困惑. 于是 Swift 标准库采取了这样的办法: 当<code>CountableRange</code>的泛型参数就是<code>Int</code>时, 禁止调用<code>subscript</code>, 当泛型参数不是<code>Int</code>时, 没这个问题, 因为本身下标就不会是0, 因此不会出现理解问题.</p><h4 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h4><p>这个 trick 在 Swift 标准库源码的实现中称为: “Statically Unavailable &amp; Dynamically Available”. 换言之, 这个方法动态是存在的, 但是你的静态代码无法调到.</p><p>考虑一般的情况</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Container</span>&lt;<span class="title">T</span>: <span class="title">Equatable</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(<span class="number">_</span> t: T)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求 T == Int 时, 无法调用 check</span></span><br><span class="line"><span class="type">Container</span>&lt;<span class="type">Int</span>&gt;().check(<span class="number">1</span>)   <span class="comment">// 期望 Compiler Error</span></span><br><span class="line"><span class="type">Container</span>&lt;<span class="type">String</span>&gt;().check(<span class="string">""</span>)   <span class="comment">// OK</span></span><br><span class="line"><span class="type">Container</span>&lt;<span class="type">Double</span>&gt;().check(<span class="number">1</span>)  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>具体实现原理是: 在特定情况下, 针对不允许调用的方法定义一个特殊的重载, 使用户调用该方法时, 会出现二义性, 从而无法通过编译.</p><p>(1) 首先给<code>Container</code>的泛型参数的条件中, 插入一个特殊的标记, 这个标记默认指向一个人畜无害的类型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">__UnavailableFlag</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SpecialEquatable</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">associatedtype</span> _Unavailable = __UnavailableFlag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) 接着针对想特殊处理的泛型类型, 改写这个标记, 使之引用自身</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">SpecialEquatable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typealias</span> _Unavailable = <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span>: <span class="title">SpecialEquatable</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>: <span class="title">SpecialEquatable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>(3) 给我们的泛型类型, 增加一个重载, 使仅针对我们要规避的参数类型, 产生二义性</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Container</span>&lt;<span class="title">T</span>: <span class="title">SpecialEquatable</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(<span class="number">_</span> t: T)</span></span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(<span class="number">_</span> t: T._Unavailable)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时, 当我们调用<code>Container.check</code>时, 当且仅当<code>T == Int</code>时, 因为<code>Int._Unavailable == Int</code>, 因此同时命中2个<code>check</code>方法, 且毫无优先级区别, 导致编译失败; 而当<code>T</code>是其他类型时, 此时<code>T._Unavailable == __UnavailableFlag</code>, 而<code>__UnavailableFlag</code>是一个 non-inhabitant type, 又称 “caseless-enum”, 因此调用者不可能产生一个这样类型的实例, 因此永远不可能产生二义性.</p><p>需要说明的是, 在上面的实现中我们把<code>Container&lt;T: Equatable&gt;</code>改写成了<code>Container&lt;T: SpecialEquatable&gt;</code>, 这会导致我们不得不把所有类型都重新遵循<code>SpecialEquatable</code>才能使之用于<code>Container</code>.<br>而在标准库设计<code>CountableRange</code>时, 是不需要的, 因为<code>CountableRange</code>本身就要求<code>T: Strideable</code>, 而<code>Strideable</code>的源码 Swift 开发人员是可控的, 因此他们只要偷偷给<code>Strideable</code>塞入一个有默认实现的 associated type, 就可以使所有原先就遵循<code>Strideable</code>的类型不改动任何代码就 work 了.</p><p>可以看到这个 trick 也有一些恼人之处:</p><ul><li>这个实现实际上巧妙地借用编译阶段的&quot;二义性&quot;错误避免了调用, 并非是真的规避调用, 我们这么实现后 error message 也并没有传达给用户我们不希望他们如此调用的出发点.</li><li>这个实现需要泛型类型本身对泛型参数有 protocol 约束, 并且我们想规避的方法也得至少有1个参数, 否则这个 trick 是无法进行的.</li><li>这个实现会至少在 ABI 层面暴露给用户多余的 associated type 定义和一个用不到的类型, 即上面的<code>associatedtype _Unavailable</code>和<code>enum __UnavailableFlag {}</code>. 当然作为 Swift Standard Library, 在输出给我们用时, API interface 里是看不到的, 但也只有 Swift 开发者能有这个优势.</li></ul><p>也许是这样的 trick 太过惊艳, 在最新的 Swift 中, 借重构<code>Range</code>族的机会, Swift 标准库把这个 trick 从曾经的<code>CountableRange</code> (注: 现在<code>CountableRange</code>只是<code>Range</code>的一个带约束同义语) 中去掉了<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>. 当然, 这样的代价就是需要我们开发者确保自己清楚<code>Range</code>的<code>Index</code>是如何生效的.</p><hr><p>这个 trick 是很有启发性的. 基于 Swift 较为成熟的类型系统, 我们可以通过泛型参数、protocol 的 associated type 等特性, 给自定义类型增加编译时可以确定的类型标记. 起到这种标记作用的类型, 仅仅辅助实现静态决议, 而在代码运行过程中并不会出现这种类型的实例对象. 因此, 这种起到标记作用的类型被称为&quot;Phantom Type&quot;. Phantom Type 是常见的代码技巧, 尤其在泛型编程中, 会在各种 practices 中经常见到.</p><hr><h3 id="泛型类型按条件遵循-protocol-before-swift-41"><a class="markdownIt-Anchor" href="#泛型类型按条件遵循-protocol-before-swift-41"></a> 泛型类型按条件遵循 protocol (before Swift 4.1)</h3><p>当前的 Swift 含有一个强大功能: Conditional Conformance<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>. 允许我们针对泛型类型在其泛型参数满足特定条件时, 使泛型类型本身遵循 protocol. 当泛型参数有一系列变化时, 泛型类型本身遵循的 protocol 还可以产生层级. 这个功能从 Swift 4.1 部分加入 (只支持编译期决议), 并在 Swift 4.2 得到彻底实现 (支持动态判断).</p><p>在 Swift 4.1 之前, 由于语言不支持此特性, 我们只能手动另辟蹊径. 例如, 期望实现下面等价的效果.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Container</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="keyword">let</span> item: <span class="type">T</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// protocol hierarchy</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">General</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Special</span>: <span class="title">General</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Container</span>: <span class="title">General</span> <span class="title">where</span> <span class="title">T</span>: <span class="title">General</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Container</span>: <span class="title">Special</span> <span class="title">where</span> <span class="title">T</span>: <span class="title">Special</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>当我们使用不同的模板参数实例化<code>Container</code>时, 形成的不同的类型本来彼此就是异构 (heterogeneous) 的, 无法再使用单个类型指示他们, 因此我们只需考虑静态情况下的问题. 并且, 某个<code>Container</code>实例是否遵循 protocol 在实例化瞬间就已经确定了, 因此可以尽早对不同的<code>Container</code>进行区分.</p><p>(1) 首先针对不同的约束情况建立一组不同的实例类型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Container</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="keyword">let</span> item: <span class="type">T</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GeneralContainer</span>&lt;<span class="title">T</span>: <span class="title">General</span>&gt;: <span class="title">General</span> </span>&#123; <span class="keyword">let</span> item: <span class="type">T</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SpecialContainer</span>&lt;<span class="title">T</span>: <span class="title">Special</span>&gt;: <span class="title">Special</span> </span>&#123; <span class="keyword">let</span> item: <span class="type">T</span> &#125;</span><br></pre></td></tr></table></figure><p>(2) 然后编写一个&quot;静态&quot;的工厂方法即可, 这个方法其实针对不同的输入参数类型, 进行重载决议, 在编译时确定遵循到哪一层 protocol.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeContainer</span>&lt;T&gt;<span class="params">(<span class="number">_</span> item: T)</span></span> -&gt; <span class="type">Container</span>&lt;<span class="type">T</span>&gt; &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="type">Container</span>(item: item) </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeContainer</span>&lt;T: General&gt;<span class="params">(<span class="number">_</span> item: T)</span></span> -&gt; <span class="type">GeneralContainer</span>&lt;<span class="type">T</span>&gt; &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="type">GeneralContainer</span>(item: item) </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeContainer</span>&lt;T: Special&gt;<span class="params">(<span class="number">_</span> item: T)</span></span> -&gt; <span class="type">SpecialContainer</span>&lt;<span class="type">T</span>&gt; &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="type">SpecialContainer</span>(item: item) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方案的缺陷在于: 当同时存在多组彼此正交的 protocol 体系时, 我们要定义的泛型类型族会很庞大, 需要定义的类型个数是各个 protocol 体系笛卡尔积的尺寸.</p><p>在 Swift 4.1 前, Swift Standard Library 对<code>Slice&lt;Base: Collection&gt;</code>就是这么处理的, 由于 <code>Collection</code>丰富的继承体系, 要定义的<code>Slice</code>变体也非常多. 实际上:</p><ul><li>在 index 构建方面, <code>Collection</code>派生出<code>BidirectionalCollection</code>和<code>RandomAccessCollection</code></li><li>在 in-place mutation 方面, <code>Collection</code>派生出<code>MutableCollection</code></li><li>在可变长方面, <code>Collection</code>派生出<code>RangeReplaceableCollection</code></li></ul><p>因此只能建立总计<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">(1 + 1) \cdot (1 + 1) \cdot (1 + 2) = 12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span>个 concrete 的<code>Slice</code>变体.</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0157-recursive-protocol-constraints.md" target="_blank" rel="noopener">https://github.com/apple/swift-evolution/blob/master/proposals/0157-recursive-protocol-constraints.md</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://swiftdoc.org/v3.1/type/countablerange/" target="_blank" rel="noopener">https://swiftdoc.org/v3.1/type/countablerange/</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0143-conditional-conformances.md" target="_blank" rel="noopener">https://github.com/apple/swift-evolution/blob/master/proposals/0143-conditional-conformances.md</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;ul class=&quot;markdownIt-TOC&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%99%AE%E9%80%9A-practices&quot;&gt;普通 Practices&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#availability-checks&quot;&gt;Availability checks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%B4%BB%E7%94%A8-string-backed-enum&quot;&gt;活用 “String-backed” enum&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86&quot;&gt;背景知识&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%A1%88%E4%BE%8B&quot;&gt;案例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tricks-patterns&quot;&gt;Tricks &amp;amp; Patterns&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%BB%99-protocol-%E5%A2%9E%E5%8A%A0-recursive-constraints-before-swift-41&quot;&gt;给 protocol 增加 recursive constraints (before Swift 4.1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%B3%9B%E5%9E%8B%E5%AF%B9%E8%B1%A1%E6%8E%92%E9%99%A4%E7%89%B9%E4%BE%8B%E8%B0%83%E7%94%A8&quot;&gt;泛型对象排除特例调用&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%97%AE%E9%A2%98&quot;&gt;问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%9C%BA%E6%99%AF&quot;&gt;场景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%9E%E7%8E%B0&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E6%8C%89%E6%9D%A1%E4%BB%B6%E9%81%B5%E5%BE%AA-protocol-before-swift-41&quot;&gt;泛型类型按条件遵循 protocol (before Swift 4.1)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;原文成于2018年&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文积累学习 Swift 过程中获取到的好技巧, 以及 Swift Standard Library 使用的优秀范式 (tricks).&lt;/p&gt;
&lt;h2 id=&quot;普通-practices&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#普通-practices&quot;&gt;&lt;/a&gt; 普通 Practices&lt;/h2&gt;
&lt;h3 id=&quot;availability-checks&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#availability-checks&quot;&gt;&lt;/a&gt; Availability checks&lt;/h3&gt;
&lt;p&gt;使用 availability checks 将超出指定的&amp;quot;Base SDK&amp;quot;版本的代码块隔离起来. 在运行时, 系统会根据运行环境动态 check 该代码是否执行.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@available(iOS 9.0, *)&lt;/code&gt;, method, type 定义时.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if #available(iOS 9.0, *)&lt;/code&gt;, 使用 method, type 时.&lt;/li&gt;
&lt;li&gt;支持 guard 作为 early exit.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以替代相对应的早期的以下调用:&lt;br&gt;
&lt;code&gt;UIDevice.current.systemVersion.compare(&amp;quot;9.0&amp;quot;, options: .numeric) == .orderedAscending&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;活用-string-backed-enum&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#活用-string-backed-enum&quot;&gt;&lt;/a&gt; 活用 “String-backed” enum&lt;/h3&gt;
&lt;h4 id=&quot;背景知识&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景知识&quot;&gt;&lt;/a&gt; 背景知识&lt;/h4&gt;
&lt;p&gt;在众多基于 raw value 的 enum 中, raw value 是&lt;code&gt;String&lt;/code&gt;的最为特殊, 因为这样的 enum 在定义各个 case 时, 可以省去显式写出用来初始化该 enum 的 raw value. 这种情况下, 编译器默认追加代码, 使用各个 case identifier 的同名字符串作为 raw value.&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 各行 case 可以省略 // 之后的部分&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ImageIdentifier&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;String&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; centerButton &lt;span class=&quot;comment&quot;&gt;// = &quot;centerButton&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; myFavorites &lt;span class=&quot;comment&quot;&gt;// = &quot;myFavorites&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;另一方面, 这样的 enum 默认遵循&lt;code&gt;RawRepresentable&lt;/code&gt;, 且关联类型&lt;code&gt;RawValue == String&lt;/code&gt;. 这方便我们对于一系列有相同特征的 enum 依靠 protocol 提供统一操作.&lt;/p&gt;
&lt;h4 id=&quot;案例&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#案例&quot;&gt;&lt;/a&gt; 案例&lt;/h4&gt;
&lt;p&gt;下述技巧最早出现于&lt;a href=&quot;https://web.archive.org/web/20200108191946/https://developer.apple.com/videos/play/wwdc2015/411/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WWDC 2015, session 403&lt;/a&gt;.&lt;br&gt;
该 video 已经被 apple 从公开列表中移除, 此处提供的是 web.archive 上的缓存.&lt;br&gt;
也可以尝试直接获取 &lt;a href=&quot;https://devstreaming-cdn.apple.com/videos/wwdc/2015/4119flfsnsgmlfy/411/411_hd_swift_in_practice.mp4?dl=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;video&lt;/a&gt; 和 &lt;a href=&quot;https://devstreaming-cdn.apple.com/videos/wwdc/2015/4119flfsnsgmlfy/411/411_swift_in_practice.pdf?dl=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pdf&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    <category term="Swift" scheme="https://crystdragon.github.io/categories/swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://crystdragon.github.io/2020/hello-world/"/>
    <id>https://crystdragon.github.io/2020/hello-world/</id>
    <published>2020-06-30T16:00:00.000Z</published>
    <updated>2020-11-11T02:24:41.103Z</updated>
    
    <content type="html"><![CDATA[<p>Hi, 很高兴认识你, 我是 Lincoln. 明面上是一名 iOS 开发者, Swifter. 私下喜欢算法, 图形渲染, 数学.<br>这是我的 <a href="/Resume.pdf">Resume</a>.he</p><p>2020年全球的疫情改变了世界, 也改变了我. 我喜欢记录和分享技术, 但以前除了在公司内部分享或与人当面交流, 我从未尝试把文字放到互联网上. 我觉得现在的环境对做出这样的改变是一个非常好的时机.</p><p>这里的文字主要有两部分内容. 一部分是正儿八经的博客, 另一部分是<a href="/categories/Notes/">十足随意的笔记</a>. 前者适合拿出来跟大家探讨, 但后者只能当成自己学习时的一些总结或提纲. 有些文章都是过去很久之前写成的, 我也趁这个把它们搬进博客的机会, 重新梳理或归纳了一下. 我确保这里的每一篇都是我自己对某个技术点的感悟, 绝不会照搬 copy 网上现有的东西. 如果阅读某一篇文字的你能从里面的某个地方有所收获, 自然我的努力也没有白费. 当然我更愿意你给我的文章提一些建议, 独乐乐不如众乐乐 xD.</p><p>我对网页前端开发有兴趣, 但远远称不上合格. 因此这个站点选择了最为基础的设施. 我使用了 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 作为网站框架, 并<a href="https://hexo.io/docs/github-pages#Private-repository" target="_blank" rel="noopener">托管</a>在 <a href="https://pages.github.com" target="_blank" rel="noopener">GitHub Pages</a> 上. 我使用的主题是 Hexo 最为基础的 landscape 风格. 平时的文章都是以 markdown 写成, 为了超越默认的 hexo markdown renderer 支持的功能, 我使用了 <a href="https://github.com/CHENXCHEN/hexo-renderer-markdown-it-plus" target="_blank" rel="noopener">hexo-renderer-markdown-it-plus</a> 插件来支持数学公式、目录、脚注等功能; 使用了<a href="https://github.com/xcodebuild/hexo-asset-image" target="_blank" rel="noopener">hexo-asset-image</a> 插件来支持插入 local image. 我选择了 <a href="https://disqus.com" target="_blank" rel="noopener">Disqus</a> 来托管每篇文章的评论, 使用 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a> 自动生成 feed 订阅. 最后, 我使用 <a href="https://github.com/hexojs/hexo-generator-sitemap" target="_blank" rel="noopener">hexo-generator-sitemap</a> 插件来自动生成 sitemap 供搜索引擎索引页面.</p><hr><p><a href="https://oleb.net/blog/2017/06/chris-lattner-wwdc-swift-panel/#in-which-fields-would-you-like-to-see-swift-in-the-future" target="_blank" rel="noopener">期待 Swift 统治世界😂</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hi, 很高兴认识你, 我是 Lincoln. 明面上是一名 iOS 开发者, Swifter. 私下喜欢算法, 图形渲染, 数学.&lt;br&gt;
这是我的 &lt;a href=&quot;/Resume.pdf&quot;&gt;Resume&lt;/a&gt;.he&lt;/p&gt;
&lt;p&gt;2020年全球的疫情改变了世界, 也</summary>
      
    
    
    
    <category term="Diary" scheme="https://crystdragon.github.io/categories/diary/"/>
    
    
  </entry>
  
</feed>
